--CREATE TABLE NOMBRE [SOLO ADMINTE _ Y $ COMO CARACTERES RAROS]
--CREATE TABLE NOMBRE
         --([NOMBRE CAMPO] [TIPO], 
         --         "        "   ,
         --         ......
         --) TABLESPACE[NOMBRE TABLESPACE CREADO Y CON ACCESO]; *SI NO PONES NADA COGE EL TABLESPACE POR DEFECTO.

--TIPO DE DATOS [TIPO]:

       --CARACTER:
       
          --CHAR = CHAR(1)
          --CHAR(10) = 2Kb
          --NCHAR(10) = 1Kb
          --VARCHAR(10) = 4Kb
          --VARCHAR2(10) = 4Kb
          --NVARCHAR2(10) = 2Kb
          --LONG  = 2Gb *DESFASADO, NO SE USA (SOLO PUEDE HABER UN LONG EN UNA TABLA)
          
       --NUMERICO:
       
          --INTEGER *REDONDEA AL ENTERO 
          --NUMBER
          --NUMBER(4) *HASTA 4 DIGITOS
          --NUMBER(6,2) *HASTA 4 ENTEROS Y 2 DECIMALES( 6-2 = 4)
          
       --BINARIOS: (IMAGENES, PDF, ETC...)
       
          --RAW = 2Kb          * DESFASADOS
          --LONG RAW = 2Gb     * DESFASADOS
          
          --LOB (FAMILIA DE TIPOS)
                --BFILE (ENLACE, PUNTERO, LINK, ETC...) NO SE GUARDA EL ARCHIVO EN ORACLE
                --BLOB = 4Gb SI SE GUARDA EL ARCHIVO EN LA TABLA DE ORACLE (EN BINARIO)
                --CLOB = 4Gb (CARACTER A CARACTER)
                
        --ROWID: (DIRECCION FISISCA DE UNA TUPLA)
           
          --000000(Nº SEGMENTO) FFF (Nº FICHERO) BBBBBB (Nº BLOQUE) XXX(Nº FILA)
          --000000FFFBBBBBBXXX
          
        --DATE: (7 DIGITOS: SIGLO, AÑO, MES, DIA, HORA, MINUTOS, SEGUNDO)
        
          --TIMESTAND (MAS DIGITOS, MAS ESPECIFICO)
          
  --USER__(CREADAS POR EL USUARIO)  TABLES
  --ALL__(CON ACCESO)               TABLES
  --DBA__(ADMINISTRADOR)            TABLES
  
  --USER__(CREADAS POR EL USUARIO)  OBJECT
  --ALL__(CON ACCESO)               OBJECT
  --DBA__(ADMINISTRADOR)            OBJECT
  
  --USER__(CREADAS POR EL USUARIO)  CATALOG
  --ALL__(CON ACCESO)               CATALOG
  --DBA__(ADMINISTRADOR)            CATALOG
  
--DROP PARA BORRAR TABLAS, OBJETOS

--DELETE PARA BORRAR TUBPLAS

--ALTER SESSION (PARA GUARDAR EL FORMATO EN UNA "VARIABLE" PARA LA SESION )
          
CREATE TABLE PROBANDO
 (
 NOMBRE VARCHAR2(4000),
 EDAD NUMBER(5,2),
 FECHA DATE
 );
 
SELECT * FROM USER_TABLES
WHERE TABLE_NAME='PROBANDO';

SELECT * FROM USER_OBJECTS;
SELECT * FROM USER_CATALOG;

INSERT INTO PROBANDO VALUES ('MOYANO',555.666, '02 12 2019');
INSERT INTO PROBANDO VALUES ('MOY',34.666444444,TO_DATE('13 VIERNES 12 2019', 'DD DAY MM YYYY'));
INSERT INTO PROBANDO VALUES ('MOY',658.666444444,TO_DATE('13 VIERNES 12 2019 22:34:20', 'DD DAY MM YYYY HH24:MI:SS'));

ALTER SESSION SET NLS_DATE_FORMAT = 'DD DAY MM YYYY HH24:MI:SS';

INSERT INTO PROBANDO VALUES ('MOY',58.666, '14 VIERNES 01 2019');

SELECT * FROM PROBANDO;

DROP TABLE PROBANDO;




SELECT * FROM USER_TABLES;

--PRIMARY KEY
--CRETATE TABLE 
          --(C1 TIPO[CONSTANT------] PRIMARY KEY


DROP TABLE NOSE1;

CREATE TABLE NOSE1
(NOMBRE VARCHAR2(10),
 DNI VARCHAR2(10) CONSTRAINT PK_NOSE1 PRIMARY KEY,
 SALDO NUMBER
)TABLESPACE USUDAW;

INSERT INTO NOSE1 VALUES ('PEPE','11-b',4);
INSERT INTO NOSE1 VALUES ('MARIA','11-b',6);--DA ERROR AL DUPLICAR DATOS EN DNI
INSERT INTO NOSE1 VALUES ('JUAN','11-H',6);
SELECT * FROM NOSE1;

SELECT * FROM USER_TABLES;

SELECT * FROM USER_CONSTRAINTS
 WHERE TABLE_NAME LIKE 'NOSE1';
 
 
 
 
--PRIMARY KEY COMPARTIDA ENTRE DOS ATRIBUTOS
 
DROP TABLE NOSE2;
 
CREATE TABLE NOSE2
(NOMBRE VARCHAR2(10),
 FACTURA NUMBER,
 CLIENTE NUMBER,
 CONSTRAINT PK_NOSE2 PRIMARY KEY(FACTURA,CLIENTE)
)TABLESPACE USUDAW;
 
INSERT INTO NOSE2 VALUES ('PEPE','11',4);
INSERT INTO NOSE2 VALUES ('MARIA','16',8);
INSERT INTO NOSE2 VALUES ('JUAN','11',9);
--SE PUEDEN REPETIR ATRIBUTOS POR QUE COMPARTEN EL PRIMARY KEY

SELECT * FROM NOSE2;

SELECT * FROM USER_TABLES;

--PARA VER TODOS LOS CANSTRAINT DE LAS TABLAS
SELECT * FROM USER_CONS_COLUMNS
 WHERE TABLE_NAME LIKE 'NOSE2';
 



--UNIQUE

DROP TABLE NOSE3;
 
CREATE TABLE NOSE3
(NOMBRE VARCHAR2(10) CONSTRAINT U_NOMBRE_NOSE3 UNIQUE,
 FACTURA NUMBER,
 CLIENTE NUMBER,
 CONSTRAINT PK_NOSE3 PRIMARY KEY(FACTURA,CLIENTE)
)TABLESPACE USUDAW;
 
INSERT INTO NOSE3 VALUES ('PEPE',1,10);
INSERT INTO NOSE3 VALUES ('PEPE',1,11);
INSERT INTO NOSE3 (FACTURA,CLIENTE) VALUES (2,10);



SELECT * FROM NOSE3;

SELECT * FROM USER_TABLES;

SELECT * FROM USER_CONSTRAINTS;




--DEFAULT

DROP TABLE MOY1;
 
CREATE TABLE MOY1
(NOMBRE VARCHAR2(10) CONSTRAINT U_NOMBRE_MOY1 UNIQUE,
 FACTURA NUMBER,
 CLIENTE NUMBER,
 FECHA DATE DEFAULT SYSDATE,
 USUARIO VARCHAR2(30) DEFAULT USER,
 CIUDAD VARCHAR2(20) DEFAULT 'ALCALA DE HENARES',
 CONSTRAINT PK_MOY1 PRIMARY KEY(FACTURA,CLIENTE)
)TABLESPACE USUDAW;
 
INSERT INTO MOY1 VALUES ('JUAN', 1,1,'12 12 2020', 'USUARIO_A', 'MURCI');
INSERT INTO MOY1 (NOMBRE,FACTURA,CLIENTE) VALUES ('PEDRO', 2,2);
INSERT INTO MOY1 (NOMBRE,FACTURA,CLIENTE) VALUES ('MARIA', 3,3);


SELECT * FROM MOY1;

SELECT * FROM USER_TABLES;

SELECT * FROM USER_CONSTRAINTS;



--CHECK (TRUE, FALSE O NULL)[TRUE ADMITE TUPLA, FALSE O NULL NO LA ADMITE]
       --NO ADMITE SYSDATE, USER, Y OTRAS

DROP TABLE MOY1;
 
CREATE TABLE MOY1
(NOMBRE VARCHAR2(10) CONSTRAINT C_NOMBRE_MOY1 CHECK (NOMBRE LIKE 'A%' AND LENGTH(NOMBRE)>= 8),
 FACTURA NUMBER,
 CLIENTE NUMBER,
 CONSTRAINT PK_MOY1 PRIMARY KEY(FACTURA,CLIENTE)
)TABLESPACE USUDAW;
 
INSERT INTO MOY1 VALUES ('JUAN', 1,1);--SOLO ADMITE NOMBRES QUE EMPIEZEN POR A____ Y QUE SEAN MAYORES O IGUALES A 8 CARACTERES
INSERT INTO MOY1 VALUES ('ALBERTITO', 1,1);



SELECT * FROM MOY1;

SELECT * FROM USER_TABLES;

SELECT * FROM USER_CONSTRAINTS;



--NOMBRE, SALARIO Y COMISION (SALARIO MAS COMISION MAS DE 200 Y EL NOMBRE EN MAYUSCULAS)
DROP TABLE MOY1;
 
CREATE TABLE MOY1
(NOMBRE VARCHAR2(10) CONSTRAINT C_NOMBRE_MOY1 CHECK (NOMBRE = UPPER(NOMBRE)),
 CORREO VARCHAR2(30) CONSTRAINT C_CORREO_MOY1 CHECK (CORREO LIKE '%@.%'),
 SALARIO NUMBER, 
 COMISION NUMBER,
 CONSTRAINT C_SALARIO_MOY1 CHECK ((SALARIO + NVL(COMISION,0)) < 200)
)TABLESPACE USUDAW;
 
INSERT INTO MOY1 VALUES ('JUAN','JU@.JIJI', 100,50);
INSERT INTO MOY1 VALUES ('alberto','JU@.JIJI', 20,150);--SOLO ADMITE NOMBRES EN MAYUSCULAS
INSERT INTO MOY1 VALUES ('PEPE','JU@.JIJI', 150,150);--SOLO ADMITE SALARIO + COMISION MENOR A 200


SELECT * FROM MOY1;

SELECT * FROM USER_TABLES;

SELECT * FROM USER_CONSTRAINTS;

--CONSTRAINT 

CREATE TABLE NN
       (COD NUMBER CONSTRAINT PK_NN PRIMARY KEY INITIALLY IMMEDIATE,
        NUM NUMBER
        ) TABLESPACE USUDAW;
INSERT INTO NN VALUES (1,10);

CREATE TABLE NN
       (COD NUMBER CONSTRAINT PK_NN PRIMARY KEY INITIALLY IMMEDIATE,
        NUM NUMBER
        ) TABLESPACE USUDAW;
INSERT INTO NN VALUES (1,10);
COMMIT WORK;--SE POSTERGA LA VALIDACIÓN



--.......PRIMARY KEY........
CREATE TABLE NN
       (COD NUMBER CONSTRAINT PK_NN PRIMARY KEY,
        NOM VARCHAR2 (30),
        NUM NUMBER PRIMARY KEY
        ) TABLESPACE USUDAW;--CASCA, NO PUEDE HACERSE DOS PRIMARY KEY ASI

CREATE TABLE MOY2
       (COD NUMBER,
        NOM VARCHAR2 (30),
        NUM NUMBER,
        CONSTRAINT PK_MOY2 PRIMARY KEY (COD,NOM) INITIALLY DEFERRED
        ) TABLESPACE USUDAW;--ASI SI SE HACEN VARIAS PRIMARY KEY
        
INSERT INTO MOY2 VALUES (1, 'PEPE', 20);
INSERT INTO MOY2 VALUES (1, 'JUAN', 20);
INSERT INTO MOY2 VALUES (2, 'PEPE', 20);
INSERT INTO MOY2 VALUES (1, 'JUAN', 260);
COMMIT WORK;

SELECT * FROM MOY2;

SELECT * FROM USUER_TAB_COLS
WHERE TABLE_NAME LIKE 'MOY2';

DROP TABLE MOY2;


--NUMERO OBLIGATORIO PERO NO PK (NOT NULL)

CREATE TABLE MOY2
       (COD NUMBER,
        NOM VARCHAR2 (30),
        NUM NUMBER CONSTRAINT V_MOY2 NOT NULL INITIALLY DEFERRED,
        CONSTRAINT PK_MOY2 PRIMARY KEY (COD,NOM) INITIALLY DEFERRED
        ) TABLESPACE USUDAW;
        
INSERT INTO MOY2 VALUES (1, 'PEPE', 2);
INSERT INTO MOY2 VALUES (1, 'JUAN', 2);
INSERT INTO MOY2(COD,NOM) VALUES (1, 'ANA');

--CHECK

CREATE TABLE MOY2
       (COD NUMBER CONSTRAINT C_CODIGO CHECK (COD IN (1,2,3)),
        NOM VARCHAR2 (30),
        NUM NUMBER CONSTRAINT V_MOY2 NOT NULL INITIALLY DEFERRED,
        CONSTRAINT PK_MOY2 PRIMARY KEY (COD,NOM) INITIALLY DEFERRED
        ) TABLESPACE USUDAW;
        
 INSERT INTO MOY2 VALUES (1, 'PEPE', 5);--CHUTA
 INSERT INTO MOY2 VALUES (4, 'PEPE', 5);--NO CHUTA
 
 
--EJERCICIO.
--QUE VALIDE UN CORREO ELECTRONICO QUE TENGA UNA @ Y UN .
CREATE TABLE MOY2
       (CORREO VARCHAR (30) CONSTRAINT C_CORREO CHECK (CORREO LIKE ('%_@_%.%')),
        NOM VARCHAR2 (30),
        NUM NUMBER CONSTRAINT V_MOY2 NOT NULL INITIALLY DEFERRED,
        CONSTRAINT PK_MOY2 PRIMARY KEY (CORREO,NOM) INITIALLY DEFERRED
        ) TABLESPACE USUDAW;
        
 INSERT INTO MOY2 VALUES ('JUAN@JI.IJ', 'PEPE', 5);--CHUTA
 INSERT INTO MOY2 VALUES ('JUA@.IJ', 'PEPE', 5);--CASCA
 INSERT INTO MOY2 VALUES ('@YHY.IJ', 'PEPE', 5);--CASCA
 INSERT INTO MOY2 VALUES ('PEPE', 5);--CASCA
 
 SELECT * FROM MOY2;--CHUTA
 
 --DOS RESTRICCIONES EDAD ( ENTRE 20 Y 40) Y OFICIO (VENDEDORES, COMERCIALES, GERENTES) Y CIUDAD
 
 CREATE TABLE MOY3
        (NUM NUMBER,
         EDAD NUMBER CONSTRAINT C_EDAD CHECK (EDAD BETWEEN 20 AND 30),
         OFICIO VARCHAR2 (30) CONSTRAINT C_OFICIO CHECK (OFICIO IN ('VENDEDORES', 'COMERCIALES', 'GERENTES')INITIALLY DEFERRED,)
         CIUDAD VARCHAR2 (20) DEFAULT 'ALCALA DE HENARES'
         );
         
 INSERT INTO MOY3 VALUES (1,30,'VENDEDOR', 'TERUEL');
 INSERT INTO MOY3 VALUES (1,300,'VENDEDOR', 'TERUEL');--CASCA
 INSERT INTO MOY3 VALUES (1,30,'NOSE', 'TERUEL');--CASCA




--...........TABLAS RELACIONADAS.............

CREATE TABLE CLIENTE
       (DNI NUMBER CONSTRAINT PK_CLIENTE PRIMARY KEY,
        NOM VARCHAR2 (30)
        );


CREATE TABLE FACTURA
       (COD_F NUMBER CONSTRAINT PK_FACTURA PRIMARY KEY,
        COD_C NUMBER CONSTRAINT FK_FACTURA_CLIENTE REFERENCES CLIENTE(DNI),
        IMPORTE NUMBER
        );
        
INSERT INTO CLIENTE VALUES (10,'SANCHEZ');  
INSERT INTO CLIENTE VALUES (20,'JUAREZ');    
INSERT INTO FACTURA VALUES (1,10,200);--CASCA SIN EL INSERT EN CLIENTE

SELECT * FROM CLIENTE;
SELECT * FROM FACTURA;

DROP TABLE CLIENTE;
DROP TABLE FACTURA;

--NO PODEMOS CREAR FACTURA ANTES QUE CLIENTE, TAMPOCO PODEMOS BORRAR CLIENTE ANTES QUE FACTURA POR QUE ESTA PERTENECE A CLIENTE.

--PARA HACER BORRADO EN CASCADA (CLIENTE-FACTURA)....CASCADE CONSTRAINT
SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME IN ('CLIENTE','FACTURA');

DROP TABLE CLIENTE CASCADE CONSTRAINT;

--DELETE EN CASACADA
DROP TABLE CASCADA;
DROP TABLE FACTURA11;


CREATE TABLE CASCADA
(COD NUMBER PRIMARY KEY,
 NOM VARCHAR2 (30)
 );
 
CREATE TABLE FACTURA11
(NUM NUMBER PRIMARY KEY,
 COD NUMBER REFERENCES CASCADA(COD) ON DELETE CASCADE,
 TOTAL NUMBER
 );

INSERT INTO CASCADA VALUES (1, 'UNO');
INSERT INTO CASCADA VALUES (2,'DOS');

INSERT INTO FACTURA11 VALUES (10,1,40);
INSERT INTO FACTURA11 VALUES (11,1,50);
INSERT INTO FACTURA11 VALUES (12,2,40);

DELETE FROM CASCADA WHERE COD=1; --NO SE PUEDE BORRAR PORQUE FACTURA11 DEPENDE DE CASCADA

--PERO CON DELETE CASCADE SI SE PUEDE, AHORA YA LAS REFERENCIAS A CASCADA (FOREY KEY) YA NO EXISTEN, PEREO SI SU DATOS.
--HAY QUE INCLUIRLO EN LA CREACION DE LA TABLA HIJA.
DELETE FROM CASCADA WHERE COD=1;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME LIKE 'FACTURA11';
SELECT * FROM CASCADA;
SELECT * FROM FACTURA11;



--HASTA AHORA HEMOS VISTO ATRIBUTOS REALES (GASTAN ESPACIO)

--ATRIBUTOS VIRTUALES( NO GASTSTAN ESPACIO)

--SINTAXIS: NOM-A [TIPO] GENERATE ALWAYS AS <EXPRESION> VIRTUAL

CREATE TABLE MOY3
       (COD NUMBER CONSTRAINT PK_OTRA PRIMARY KEY,
       SALARIO NUMBER,
       COMISION NUMBER,
       TOTAL NUMBER GENERATED ALWAYS AS (COMISION + SALARIO) VIRTUAL,
       FECHA DATE
       );
       
INSERT INTO MOY3 (COD, SALARIO, COMISION, FECHA)
       VALUES (1,20,40,SYSDATE);
       
INSERT INTO MOY3 (COD, SALARIO, COMISION, FECHA)
       VALUES (2,60,400,'12/12/2050');
       
INSERT INTO MOY3
       VALUES (1,20,40,60,SYSDATE);--CASCA PORQUE AUNQUE EL VALOR VIRTUAL ES CORRECTO (20 + 40 = 60), ESTOS NO ADMITEN VALORES.
  

SELECT * FROM MOY3;

SELECT * FROM USER_SEGMENTS
       WHERE SEGMENT_NAME LIKE 'MOY3';

SELECT * FROM USER_TAB_COLS
       WHERE TABLE_NAME LIKE 'MOY3';
      

--**LLEVAR A CREACION DE TABLAS (TRUNCATE)
--SINTAXIS:
--         TRUNCATE TABLE <NOMBRE_TABLE> [DROP/REUSE]STRORAGE
--REUSE: BORRA LAS TUPLAS Y REUTILIZA LOS ESPACIOS DEL TABLESPACE
--DROP: BORRA LAS TUPLAS Y ADEMÁS LIBERA LOS STEN/CELDAS/ESPACIOS
DROP TABLE MOY4;

CREATE TABLE MOY4
(N CHAR(2000));
SELECT COUNT(*) FROM MOY4;

TRUNCATE TABLE MOY4 REUSE STORAGE;
TRUNCATE TABLE MOY4 DROP STORAGE;

SELECT * FROM USER_SEGMENTS
       WHERE SEGMENT_NAME LIDE 'MOY4';


--COPIAR DEL SU ARCHIVO PARA TERMINAR EL EJERCICIO.

--OTRO EJERCICIO DE TRUNCATE

CREATE TABLE DATOS
(COD NUMBER,
 DES VARCHAR2 (40),
 DECO GENERATED ALWAYS AS (DECODE (DES, 'MESA', 'M',
                                        'SILLA', 'S',
                                        'TABURETE','T',
                                        DES
                                   ) || '-' || LENGTH (DES)
                           ) VIRTUAL
);

INSERT INTO DATOS (COD,DES) VALUES (1,'MESA');
INSERT INTO DATOS (COD,DES) VALUES (2,'NOSE');
INSERT INTO DATOS (COD,DES) VALUES (3,'SILLA');
INSERT INTO DATOS (COD,DES) VALUES (4,'TABURETE');

SELECT * FROM DATOS;



--OTRO EJERCICIO 


CREATE TABLE CUENTA_MOY
(DNI NUMBER CONSTRAINT PK_CUENTA_MOY PRIMARY KEY,
 NOM VARCHAR2(30),
 CCC VARCHAR2(20),                           --CON PONER UNICAMENTE LA CCC NOS DESGLOSA ESTA EN LAS VIRTUALES CON SUBSTR
 ENTIDAD GENERATED ALWAYS AS (SUBSTR(CCC,1,4)) VIRTUAL,
 SUCURSAL GENERATED ALWAYS AS (SUBSTR(CCC,5,4)) VIRTUAL,
 DD GENERATED ALWAYS AS (SUBSTR(CCC,9,2)) VIRTUAL,
 CUENTA GENERATED ALWAYS AS (SUBSTR(CCC,11,10)) VIRTUAL
 );
 
INSERT INTO CUENTA_MOY(DNI,NOM,CCC)
       VALUES (1,'UNO', '11110000550123456789');
INSERT INTO CUENTA_MOY(DNI,NOM,CCC)
       VALUES (2,'DOS', '99995555449876543210');
INSERT INTO CUENTA_MOY(DNI,NOM,CCC)
       VALUES (3,'TRES', '66668888775678901234');
       
SELECT * FROM CUENTA_MOY



--EJERCICIO TABLAS HOSPITAL

CREATE TABLE HOSPITAL1
(HOSPITAL_COD NUMBER 
  



---------------------------------------------CREANDO TABLAS PROCEDENTES DE UNA SELECT----------------------------------------

--CREATE TABLE <NOMBRE[(ATRIBUTO,ATRIBUTO,......)]
         --[TABLEESPACE ____]
         --AS
         --SELECT * FROM <NOMBRE TABLA OBJETIVO>
                  --WHERE........
 
--UTIL PARA COPIAR DATOS DE OTRAS TRABLAS

--TABLA ORIGEN DEL PROFE        
SELECT * FROM PROFE.EMPLE2;

--TABLA NUEVA MIA
CREATE TABLE EMPLEMOY
       --TABLEESPACE USUDAW
       AS
       SELECT * FROM PROFE.EMPLE2;
       
SELECT * FROM EMPLEMOY;
DROP TABLE EMPLEMOY;

--TAMBIEN SE PUEDE COPIAR SOLO LOS ATRIBUTOS QUE NECESITE Y CON OTROS NOMBRES
CREATE TABLE EMPLEMOY (APE, SAL, COMM)
       AS
       SELECT APELLIDO, SALARIO, COMISION
       FROM PROFE.EMPLE2;
SELECT * FROM EMPLEMOY;

DROP TABLE EMPLEMOY;
--COPIAR CON LOS NOMBRES ORIGINALES
CREATE TABLE EMPLEMOY 
       AS
       SELECT APELLIDO, SALARIO, COMISION
       FROM PROFE.EMPLE2;
SELECT * FROM EMPLEMOY;

DROP TABLE EMPLEMOY;

--LAS CONSTRAINT NO SE COMPIAN
--SOLO SE COPIAN LAS CONSTRAIN QUE NO TENGAN NOMBRE Y LAS PK Y LAS FK NO SE COPIAN DE NINGUNA MANERA
SELECT * FROM USER_CONSTRAINTS
       WHERE TABLE_NAME IN ('PROFE.EMPLE2');
       
--COPIAMOS TABLAS PARA COMPARAR CONSTRAINS

--CREAMOS UNA TABLA RAMDOM....
DROP TABLE PRIMERA;
CREATE TABLE PRIMERA
(DNI NUMBER CONSTRAINT PK_PRIMERA_DNI PRIMARY KEY,
 X NUMBER NOT NULL,
 XX NUMBER CONSTRAINT C_SS CHECK (XX BETWEEN 1 AND 100)
 );

--COPIAMOS LA TABLA PRIMERA RAMDOM
DROP TABLE COPIAPRIMERA;
CREATE TABLE COPIAPRIMERA 
       AS
       SELECT * FROM PRIMERA;
       
SELECT * FROM USER_CONSTRAINTS
       WHERE TABLE_NAME IN ('PRIMERA', 'COPIAPRIMERA');
--PODEMOS COMPROBAR QUE LAS CONSTRAINS NO SE HAN COPIADO.



-------------------------------------MODIFICACIÓN DE TABLES-------------------------------------------------
--ALTER TABLE
        --[VARIOS FORMATOS
                  --....
                  --....
                  --....
                  --....]
DROP TABLE MODIFICAR;

CREATE TABLE MODIFICAR
(NUM NUMBER(5),
 NOM VARCHAR2(10)
 );
-----------------AÑADIMOS UNA COLUMNA O VARIAS, Y PODEMOS PONER LA CONSTRAINT 
ALTER TABLE MODIFICAR ADD (EDAD NUMBER);
ALTER TABLE MODIFICAR ADD (DNI NUMBER CONSTRAINT PK_MODIFICAR_DNI PRIMARY KEY, FECHA DATE);

-----------------BORRAMOS COLUMNAS
ALTER TABLE MODIFICAR DROP (FECHA, NOM);

--INSERTAMOS DATOS
INSERT INTO MODIFICAR VALUES(1,2,548587);

-----------------NO SE PUEDE AÑADIR COLUMNAS DESPUES DE AÑADIR DATOS, TIENE QUE ESTAR VACIA
INSERT INTO MODIFICAR VALUES(1, 'UNO');
ALTER TABLE MODIFICAR ADD(X NUMBER NOT NULL);--CASCA

------------------SE PUEDE HACER LO ANTERIOR HACIENDO EL CAMPO OBLIGATORIO CON CHECK
ALTER TABLE MODIFICAR ADD(X NUMBER CONSTRAINT C_NULO CHECK (X IS NOT NULL));
ALTER TABLE MODIFICAR ADD(Y NUMBER CHECK (Y IS NOT NULL));

INSERT INTO MODIFICAR VALUES (2,'DOS', 20, 1);
INSERT INTO MODIFICAR (NUM,NOM) VALUES (3,'TRES');--CASCA POR QUE NECESITA QUE X E Y SEAN OBLIGATORIAS

--------------------PARA AÑADIR UNA PRIMARY KEY YA CREADA....
INSERT INTO MODIFICAR VALUES(1, 'UNO');
ALTER TABLE MODIFICAR ADD (DNI NUMBER PRIMARY KEY);--NO SE PUEDE COMO ANTERIORMETE (NOT NULL)
      --SE HACE ASI
ALTER TABLE MODIFICAR ADD (DNI NUMBER CHECK (DNI IS NOT NULL)UNIQUE);

INSERT INTO MODIFICAR VALUES (2, 'DOS', 10);

---------------------PODEMOS MODIFICAR CON MODIFY
--SIN DATAS SE MODIFICA FACILMENTE
ALTER TABLE MODIFICAR MODIFY (NUM NUMBER(3), NOM VARCHAR2(12));

--CON DATOS ES DIFERENTE
INSERT INTO MODIFICAR VALUES(12345, 'UNOTGTR');

--CON LAS CADENAS SOLO SE PUEDE REDUCIR EL TAMAÑO HASTA EL LIMITE SIN MODIFICAR LOS DATOS
--CON LOS NUMBER SOLO SE PUEDEN AMPLIAR LOS DATOS
ALTER TABLE MODIFICAR MODIFY (NOM VARCHAR2(7));
ALTER TABLE MODIFICAR MODIFY (NOM VARCHAR2(5));--CASCA POR QUE NUM TINE MAS DE 5 CARACTERES
ALTER TABLE MODIFICAR MODIFY (NUM NUMBER (10));
ALTER TABLE MODIFICAR MODIFY (NUM NUMBER (4));--CASCA POR QUE LOS NUMBER NO SE PUEDEN REDUCIR

--TAMBIEN PODEMOS MODIFICAR LAS CONSTRAINS CON MODIFY
ALTER TABLE MODIFICAR MODIFY (NUM NUMBER(5) CONSTRAINT PK_MODIFICAR_NUM PRIMARY KEY);

--CON DATOS NO PODEMOS AÑADIR 
INSERT INTO MODIFICAR VALUES(1, 'UNO');
INSERT INTO MODIFICAR VALUES(2, 'DOS');

---------------------------------------CONSTRAINT-------------------------------------------
---------------------------------PODEMOS AÑADIR CONSTRAINT SIN MODIFY CON ADD---------------------------------------
       DROP TABLE NOSE3000;
       
CREATE TABLE NOSE3000
(X NUMBER,
 XX NUMBER
 );

ALTER TABLE NOSE3000 ADD CONSTRAINT PK_NOSE3000_X PRIMARY KEY(X);

------------------------------------------NO PODEMOS AÑADIR DEFAUL CON ADD PERO SI CON MODIFY

ALTER TABLE NOSE3000 ADD CONSTRAINT D_NOSE3000_X DEFAULT 0;--CASCA
ALTER TABLE NOSE3000 MODIFY (XX NUMBER DEFAULT 0); --CON MODIFY SI PODEMOS POR QUE MODIFICAMOS TODO EL ATRIBUTO

SELECT * FROM MODIFICAR;

------------------------------------------PODEMOS BORRAR CONSTRAINT CON DROP

SELECT * FROM USER_CONS_COLUMNS
        WHERE TABLE_NAME LIKE 'NOSE3000';

ALTER TABLE NOSE3000 DROP CONSTRAINT PK_NOSE3000_X;

SELECT * FROM USER_CONS_COLUMNS
        WHERE TABLE_NAME LIKE 'NOSE3000';
    
--LOS DATOS SE MANTIENEN, SOLO SE BORRA EL ATRIBUTO CONTRAINT

--------------------------------------PODEMOS ACTIVAR O DESACTIVAR LAS CONSTRAINT
          DROP TABLE NOSE3000;

CREATE TABLE NOSE3000
(X NUMBER CONSTRAINT C_NOSE CHECK (X IN(1,2,4)),
 XX NUMBER
 );
 
 INSERT INTO NOSE3000 VALUES (1,2);
 INSERT INTO NOSE3000 VALUES (3,44); --NO SE PERMITE MIETRAS LA CONSTRAINT ESTE ACTIVA
 
 SELECT * FROM NOSE3000;
 
 SELECT * FROM USER_CONS_COLUMNS
        WHERE TABLE_NAME LIKE 'NOSE3000'; 

ALTER TABLE NOSE3000 DISABLE CONSTRAINT C_NOSE;

SELECT * FROM USER_CONS_COLUMNS
        WHERE TABLE_NAME LIKE 'NOSE3000'; 
     
 
----------------PARA BUSCAR LA RESTRICCION QUE SE INCUMPLE--------------------
--CREAMOS TABLA
          DROP TABLE FALLO;

CREATE TABLE FALLO
(FILA ROWID,
 USU VARCHAR2 (40),
 TABLA VARCHAR2 (40),
 CUAL VARCHAR2 (40)
 );
--LEVANTAMOS LA CONSTRAINT
ALTER TABLE NOSE3000 ENABLE CONSTRAINT C_NOSE EXCEPTIONS INTO FALLO; 

--
SELECT X, ROWID
FROM NOSE3000;

--COMPARAMOS LOS DATOS ENTRE TABLAS PARA VER EL DATO QUE FALLO PARA PODER LEVANTAR LA RESTRICCION
SELECT * FROM NOSE3000, FALLO
WHERE NOSE3000.ROWID = FALLO.FILA;
--ACATUALIZAMOS LA TABLA PARA ARREGLAR EL ERROR, EL 3 
UPDATE NOSE3000
SET X = 2
WHERE XX = 44;

TRUNCATE TABLE FALLO;

SELECT * FROM FALLO;

--1º CREAMOS LA TABLA NOSE3000
--2º AÑADIMOS DATOS
--3º LEVANTAMOS LA CONSTRAINT: ---ALTER TABLE NOSE3000 DISABLE CONSTRAINT C_NOSE;
--4º ANADIMOS DATOS SIN RESTRINCCION:  INSERT INTO NOSE3000 VALUES (3,44);
--5º CREAMOS TABLA FALLO
--6º LEVANTAMOS LA CONSTRAINT CON EXECPTION PARA LLENAR LA TABLA FALLO CON SUS EXECPIONES: --ALTER TABLE NOSE3000 ENABLE CONSTRAINT C_NOSE EXCEPTIONS INTO FALLO; 
--7º COMPARAMOS LOS DATOS ENTRE TABLAS PARA VER EL DATO QUE FALLO PARA PODER LEVANTAR LA RESTRICCION:
--              SELECT * FROM NOSE3000, FALLO
--              WHERE NOSE3000.ROWID = FALLO.FILA;
--8º ACATUALIZAMOS LA TABLA PARA ARREGLAR EL ERROR, EL 3
--9º TRUNCAMOS LA TABLA FALLO PARA QUITAR LOS DATOS DEL ERROR
--10º VOLVEMOS A LEVANTAR LA RESTRICCION: --ALTER TABLE NOSE3000 ENABLE CONSTRAINT C_NOSE EXCEPTIONS INTO FALLO;
--11º COMPROVAMOS LA TABLA NOSE3000:  --SELECT * FROM NOSE3000;


--EJEMPLO
CREATE TABLE NOSE3000
(X NUMBER,
 XX NUMBER
 );
 ALTER TABLE NOSE3000 MODIFY (X NUMBER CONSTRAINT PK_NOSE3000_X PRIMARY KEY);
 
 SELECT * FROM USER_CONS_COLUMNS
        WHERE TABLE_NAME LIKE 'NOSE3000';
        
--OTRA FORMA DE SACAR LA INFO CORRUPTA ES CON UNA TABLA SOLO LECTURA 

          DROP TABLE NOSE3000;

CREATE TABLE NOSE3000
(X NUMBER CONSTRAINT C_NOSE CHECK (X IN(1,2,4)),
 XX NUMBER
 );
 
 INSERT INTO NOSE3000 VALUES (1,2);
 
 --HACEMOS LA TABLA A SOLO LECTURA
 ALTER TABLE NOSE3000 READ ONLY ;
 
 SELECT * FROM NOSE3000;
 
 SELECT * FROM USER_TABLES 
 WHERE TABLE_NAME LIKE 'NOSE3000'; --EN READ ONLY ESTA EN YES
 
 --PASAMOS LA TABLA A ESCRITURA
ALTER TABLE NOSE3000 READ WRITE;

 SELECT * FROM USER_TABLES 
 WHERE TABLE_NAME LIKE 'NOSE3000'; --EN READ ONLY ESTA EN NO
 
 
 
 
 
 ------------------------------------TABLAS COMPRIMIDAS-------------------------------------------------
 ------------------------------EL ACCESO ES MÁS RAPIDO SI ESTA COMPRIMIDO.
                             --TABLAS COMPRIMIDAS:     
                                  --ACCESO A LOS DATOS MAS LENTO
                                  --NUMERO DE BLOQUES MUCHO --MENOR--
                             --TABLAS NORMALES:     
                                  --ACCESO A LOS DATOS MAS RÁPIDO
                                  --NUMERO DE BLOQUES MUCHO --MAYOR--

-------SINTAXIS                                 
--CREATE TABLE <NOMBRE>
--(<ATRIBUTO 1>
--[ATRIBUTO 2]
--[........]
--)[TABLESPACE <NOMBRE>]
--[COMPRESS]
--[COMPRESS FOR ALL OPERATIONS]
--[COMPRESS FOR OMPT]

--NOMBRE:
-- NC = NO COMPRIMIDAD
-- CB = COMPRESION BÁSICA
-- C1 = COMPRESION PRIMERA
CREATE TABLE NC
(X CHAR(20),
XX CHAR(20)
)TABLESPACE USUDAW;

CREATE TABLE CB
(X CHAR(20),
XX CHAR(20)
)COMPRESS TABLESPACE USUDAW;

CREATE TABLE C1
(X CHAR(20),
XX CHAR(20)
)COMPRESS FOR ALL OPERATIONS;

SELECT TABLE_NAME, COMPRESSION, COMPRESS_FOR
FROM USER_TABLES
WHERE TABLE_NAME IN ('NC', 'CB', 'C1');

--SANTIAGO RELLENA LAS TABLAS CON 500000 TUPLAS
SELECT COUNT(*) FROM PROFE.NC;
SELECT COUNT(*) FROM PROFE.CB;
SELECT COUNT(*) FROM PROFE.C1;

--ESTO ES PARA VER LOS BLOQUES DE LAS TABLAS Y COMPROBAR QUE C1 ES MEJOR COMPRESION QUE CB
SELECT SEGMENT_NAME, BLOCKS, ROUND (BYTES/1024/1024,2) MEGAS
FROM USER_SEGMENTS
WHERE SEGMENT_NAME IN ('PROFE.NC', 'PROFE.CB', 'PROFE.C1');

--------------------PODEMOS HACER CASI CUALQUIER ACCIÓN CON ALTER TABLE, PERO EN C1, EN CB ES MÁS LIMITADO
--BORRAMOS COLUMAS, EN CB NO SE PUEDE
ALTER TABLE CB DROP (XX);

--PERO EN C1 SI SE PUEDE
ALTER TABLE C1 DROP (XX);

-----------------------QUITAMOS LA COMPRESION CON NOCOMPRESS Y PODEMOS VOLVER A COMPRIMIRLAS
ALTER TABLE CB NOCOMPRESS;
ALTER TABLE C1 NOCOMPRESS;
ALTER TABLE CB COMPRESS;
ALTER TABLE C1 COMPRESS FOR ALL OPERATIONS;

SELECT TABLE_NAME, COMPRESSION, COMPRESS_FOR
FROM USER_TABLES
WHERE TABLE_NAME IN ('NC', 'CB', 'C1');

INSERT INTO CB VALUES ((SELECT 'V' FROM DUAL), 'X');

ALTER TABLE CB COMPRESS FOR ALL OPERATIONS;

--TODOS LOS CAMBIOS CON ALTER TABLE SOLO ES EFECTIVO PARA LAS NUEVAS TUPLAS.
--LAS TUPLAS ANTERIORES A LOS CAMBIOS SE QUEDAN CON SU VERSIÓN ANTERIOR.

ALTER TABLE CB COMPRESS;

--CON MOVE PASO LAS TUPLAS NUEVAS Y TAMBIEN LAS VIEJAS. MUY IMPORTANTE.
ALTER TABLE CB MOVE COMPRESS FOR ALL OPERATIONS;

ALTER TABLE CB READ ONLY;



------------------------------------TABLAS TEMPORALES--------------------------------------------
--NO SOPORTA PARTICIONAMIENTO
--NO SOPORTA COMPRESIÓN
--NO SOPORTA TABLESPACE


--LAS TUPLAS SE BORRAN DE DOS FORMAS:
     --POR CIERRE DE SESIÓN
     --POR COMMIT O ROLLBACK
     
--SINTAXIS
--


CREATE GLOBAL TEMPORARY TABLE SANCHEZ
(X NUMBER CONSTRAINT PK_SANCHEZ PRIMARY KEY,
XX VARCHAR2 (10)
);

INSERT INTO SANCHEZ VALUES (1,'PP');

SELECT * FROM SANCHEZ;


--LAS TABLAS NO GENERAN REDOLOG (LOGGING), ES DECIR, SI RESTAURAS SISTEMA, PIERDES LOS DATOS DE LA TABLA.
SELECT * FROM USER_TABLES
WHERE TABLE_NAME IN ('NOSE3000', 'SANCHEZ');


--PODEMOS COMPARTIR UNA TABLA ENTRE USUARIOS
--GRANT ALL ON SANCHEZ TO ROL_DAW;

INSERT INTO PROFE.SANCHEZ VALUES (56,'VV');
INSERT INTO PROFE.SANCHEZ VALUES (89,'DoD');

SELECT * FROM PROFE.SANCHEZ;


--CON COMMIT RESERVE ROWS, AUNQUE COMITEMOS LAS TUPLAS SE MANTIENEN
CREATE GLOBAL TEMPORARY TABLE IGLESIAS
(X NUMBER PRIMARY KEY,
 XX VARCHAR2 (10)
) ON COMMIT PRESERVE ROWS;

INSERT INTO IGLESIAS VALUES (1,'FEO');
INSERT INTO IGLESIAS VALUES (5,'MALO');
SELECT * FROM IGLESIAS;
COMMIT WORK;--NO SE BORRAN
-- SE BORRAN CUANDO CERRAMOS LA SESIÓN
INSERT INTO IGLESIAS VALUES (4,'BUENO');
--EL ROLLBACK FUNCIONA COMO ESPERAMOS, 
INSERT INTO IGLESIAS VALUES (7,'LA CHICA');

INSERT INTO PROFE.IGLESIAS VALUES (1,'FEO');
INSERT INTO PROFE.IGLESIAS VALUES (5,'MALO');
SELECT * FROM PROFE.IGLESIAS;

INSERT INTO PROFE.IGLESIAS VALUES (4,'BUENO');
--EL ROLLBACK FUNCIONA COMO ESPERAMOS, 
INSERT INTO IGLESIAS VALUES (7,'LA CHICA');




-----------------------------CONSULTAS PARALELAS----------------------------------------
--------POR CONSULTA/INSTRUCCION
--------POR SESIÓN
--------POR TABLA

-----------POR CONSULTA--------------------
--ALTER SYSTEM FLUSH SAHRED_POOL;

--SELECT /*+ PARALLEL(4) */ * FROM EMPLE;
--SELECT * FROM EMPLE;

--ALIAS (<ALIAS>,<N1 DE NUCLEOS DE LA MAQUINA>)
--SELECT /*+ PARALLEL(E,4) */ APELLIDO FROM EMPLE E;
--SELECT /*+ PARALLEL (E,4) PARALLEL(D,4) */
         --APELLIDO, LOC
         --FROM EMPLE E
         --INNER JOIN DEPART D
         --ON E.DEPT_NO = D.DEPT_NO;
 

----------------POR SESION------------------------        
--PARALELAJE PARA QUERY, DML, DDL


--SOLO PARA CONSULTAS DE CUALQUIER TABLA
ALTER SESSION ENABLE PARALLEL QUERY;

--PARA TODO MENOS SELECT
ALTER SESSION ENABLE PARALLEL DML;

--PARA CREAR TABLAS, ETC...
--PARA DML SOLO FUNCIONA SI LAS TABLAS ESTAN PARTICIONADAS
ALTER SESSION ENABLE PARALLEL DDL;

--PARA DESACTIVAR
ALTER SESSION DISABLE PARALLEL QUERY;


--CON ESTO FIJAMOS LOS CORES PARA TODA LA SESSION
--ESTO VALE TANTO PARA QUERY COMO PARA DML Y DLL.
ALTER SESSION FORCE PARALLEL QUERY PARALLEL 4;


--------------------POR TABLA------------------------------------
--PODEMOS DEFINIR LOS CORES POR TABLA
--ALTER TABLE <NOMBRE DE LA TABLA> PARALLEL <Nº DE CORES>;
--ALTER TABLE <NOMBRE DE LA TABLA> PARALLEL (DEGREEE <Nº DE CORES>);
ALTER TABLE CUENTA_MOY PARALLEL 2;

SELECT TABLE_NAME, DEGREE FROM USER_TABLES
  WHERE TABLE_NAME IN ('CUENTA_MOY', 'NOSE3');

--PARA DEJAR TODAS LAS TABLAS EN NUCLES POR DEFECTO

--DEGREE DEFAULT

ALTER TABLE CUENTA_MOY NOPARALLEL;


--------------------------------------------------------------------------------------------
------------------------------------TABLAS EXTERNAS-----------------------------------------
--------------------------------------------------------------------------------------------

--NO GASTAN EXTEND
--NO PODEMOS PONER RESTRICCIONES

CREATE TABLE EXTERNA
(DEP NUMBER, 
 SALDO NUMBER(12,2),
 LOC VARCHAR2 (20),
 DNOMBRE VARCHAR2 (30),
 FECHA DATE
 )
 ORGANIZATION EXTERNAL
 (TYPE ORACLE_LOADER DEFAULT DIRECTORY FICHEROS
 ACCESS PARAMETERS (RECORDS DELIMITED BY NEWLINE
                    SKIP O
                    FIELDS TERMINATED BY ','
                    MISSING FIELD VALUES ARE NULL
                            (DEP INTEGER EXTERNAL(2),
                             SALDO FLOAT EXTERNAL(12),
                             LOC CHAR (20),
                             DNOMBRE CHAR (30),
                             FECHA CHAR (10) DATE_FORMAT DATE MASK "DD-MM-YYYY"
                             )
                    )
 LOCATION ('tata1.TXT')
 );
 
 
 
 ------------------------------------------------------------------------------------------
 --                                PARTICIONAMIENTO
 ------------------------------------------------------------------------------------------
 
 --RANGO
 
 --CREAMOS UNA TABLA Y LA PARTICIONAMOS
 
 --PUEDE ESTAR EN DIFIRENTES TABLESPACES, DISCOS, ETC...
 
 
--PARA VER EL TABLESPACE
SELECT * FROM USER_USERS;
 
DROP TABLE ESTUDIANTES PURGE;  --PURGE LA ELIMINA TAMBIEN DE LA PAPELERA
 
CREATE TABLE ESTUDIANTES
(DNI NUMBER CONSTRAINT PK_ESTUDIANTES_DNI PRIMARY KEY,
 NOM VARCHAR2 (30),
 EDAD NUMBER,
 CURSO NUMBER
 )
 --PODEMOS CAMBIAR LOS TABLESPACES (SON IGUALES AHORA POR QUE NO TENEMOS ACCESO A MÁS)
 PARTITION BY RANGE(CURSO)
 (PARTITION UNO VALUES LESS THAN (2) TABLESPACE USUDAW,
  PARTITION DOS VALUES LESS THAN (3) TABLESPACE USUDAW,
  PARTITION TRES VALUES LESS THAN (4) TABLESPACE USUDAW,
  PARTITION CUATRO VALUES LESS THAN (5)  TABLESPACE USUDAW,
  PARTITION ERRORES VALUES LESS THAN (MAXVALUE) --SE SUELE HACER UNA PARTICIÓN CAJON DESASTRE PARA LOS DATOS ERRORES.
  )COMPRESS;--PODEMOS COMPRIMIRLA

INSERT INTO ESTUDIANTES VALUES (10, 'DIEZ',10,2);
INSERT INTO ESTUDIANTES VALUES (12, 'DOCE',10,3);
INSERT INTO ESTUDIANTES VALUES (14, 'CATORCE',10,1);
INSERT INTO ESTUDIANTES VALUES (16, 'DIECISEIS',10,2);
INSERT INTO ESTUDIANTES VALUES (18, 'DIECIOCHO',10,3);
INSERT INTO ESTUDIANTES VALUES (20, 'VEINTE',10,4);
INSERT INTO ESTUDIANTES VALUES (22, 'VEINTIDOS',10,5);

 
SELECT * FROM ESTUDIANTES;


--PARA SACAR SOLAMENTE LOS DEL CURSO 1

SELECT * FROM ESTUDIANTES
 WHERE CURSO = 1;
 
--CON PARTITION MUCHO MÁS RÁPIDO Y SIN WHERE

SELECT * FROM ESTUDIANTES PARTITION (UNO);
SELECT * FROM ESTUDIANTES PARTITION (DOS);
SELECT * FROM ESTUDIANTES PARTITION (TRES);
SELECT * FROM ESTUDIANTES PARTITION (ERRORES);


SELECT * FROM USER_TABLES
WHERE TABLE_NAME IN ('EMPLE', 'ESTUDIANTES');

SELECT * FROM USER_EXTENTS
WHERE SEGMENT_NAME IN ('EMPLE', 'ESTUDIANTES');


SELECT * FROM USER_SEGMENTS
WHERE SEGMENT_NAME IN ('EMPLE', 'ESTUDIANTES');

SELECT * FROM USER_TAB_PARTITIONS
WHERE TABLE_NAME LIKE 'ESTUDIANTES';





---------------PARTICIONES POR STRINGS Y CLAVES VIRTUALES POR PARTICIONAMIENTO


DROP TABLE ESTUDIANTES_2 PURGE;  --PURGE LA ELIMINA TAMBIEN DE LA PAPELERA
 
CREATE TABLE ESTUDIANTES_2
(NIF VARCHAR2(9) CONSTRAINT PK_ESTUDIANTES_2_NIF PRIMARY KEY,
 LETRA GENERATED ALWAYS AS (SUBSTR(NIF,LENGTH (NIF),1)) VIRTUAL,
 EDAD NUMBER
 )
 --PODEMOS CAMBIAR LOS TABLESPACES (SON IGUALES AHORA POR QUE NO TENEMOS ACCESO A MÁS)
 PARTITION BY RANGE(LETRA)
 (PARTITION UNO VALUES LESS THAN ('H') TABLESPACE USUDAW,
  PARTITION DOS VALUES LESS THAN ('M') TABLESPACE USUDAW,
  PARTITION TRES VALUES LESS THAN ('P') TABLESPACE USUDAW,
  PARTITION CUATRO VALUES LESS THAN ('Z')  TABLESPACE USUDAW,
  PARTITION CINCO VALUES LESS THAN (MAXVALUE)  TABLESPACE USUDAW
 -- PARTITION ERRORES VALUES LESS THAN ( ) --SE SUELE HACER UNA PARTICIÓN CAJON DESASTRE PARA LOS DATOS ERRORES.
  )COMPRESS;--PODEMOS COMPRIMIRLA

INSERT INTO ESTUDIANTES_2 (NIF,EDAD) VALUES ('51997678X',10);
INSERT INTO ESTUDIANTES_2 (NIF,EDAD) VALUES ('997678G',10);
INSERT INTO ESTUDIANTES_2 (NIF,EDAD) VALUES ('51997678Z',10);
INSERT INTO ESTUDIANTES_2 VALUES ('51997678A',10);
INSERT INTO ESTUDIANTES_2 VALUES ('51997678X',10);


 
SELECT * FROM ESTUDIANTES_2;

SELECT * FROM ESTUDIANTES PARTITION (UNO);
SELECT * FROM ESTUDIANTES PARTITION (DOS);
SELECT * FROM ESTUDIANTES PARTITION (TRES);
SELECT * FROM ESTUDIANTES_2 PARTITION (CINCO);

SELECT * FROM USER_TAB_PARTITIONS;

--ACTUALIZAR UNA PARTICIÓN

UPDATE ESTUDIANTES_2
 SET EDAD = 3
  WHERE NIF = '51997678X';
  
UPDATE ESTUDIANTES_2
 PARTITION (UNO)
  SET EDAD = 8
  WHERE NIF = '997678G';
  
--PATICIÓN POR APELLIDOS DE UNA TABLA, PERO SE PUEDE HACER SIN EL SUBSTR Y LO COGE IGUAL (MIRAR APUNTES SANTIAGO)

DROP TABLE APELLIDOS_MOY PURGE;

CREATE TABLE APELLIDOS_MOY
 (NOM VARCHAR2(20) CONSTRAINT PK_APELLIDOS_MOY_NOM PRIMARY KEY,
  APE VARCHAR2(20) GENERATED ALWAYS AS (SUBSTR (NOM,1,1)) VIRTUAL,
  EDAD NUMBER
  )
  
 PARTITION BY RANGE (APE)
 (PARTITION PRI VALUES LESS THAN ('H'),
  PARTITION SEG VALUES LESS THAN ('M'),
  PARTITION TER VALUES LESS THAN ('Z'),
  PARTITION CUAR VALUES LESS THAN (MAXVALUE)
  );
 
 INSERT INTO APELLIDOS_MOY (NOM,EDAD) VALUES ('MOYANO',20);
 INSERT INTO APELLIDOS_MOY (NOM,EDAD) VALUES ('ROMERO',28);
 INSERT INTO APELLIDOS_MOY (NOM,EDAD) VALUES ('GARCIA',28);
 INSERT INTO APELLIDOS_MOY (NOM,EDAD) VALUES ('ZARAGALLO',26);
  
  
SELECT * FROM APELLIDOS_MOY;


----------------------------------PARTICIÓN POR LISTA--------------------------------------------------



CREATE TABLE APELLIDOS_MOY
 (NOM VARCHAR2(20) CONSTRAINT PK_APELLIDOS_MOY_NOM PRIMARY KEY,
  APE VARCHAR2(20) GENERATED ALWAYS AS (SUBSTR (NOM,1,1)) VIRTUAL,
  EDAD NUMBER
  )
  
 PARTITION BY LIST (APE) -----LIST
 (PARTITION PRI VALUES ('C', 'D', 'H', 'L'),----NO SE PONE LESS THAN
  PARTITION SEG VALUES ('O', 'R', 'V', 'Z'),
  PARTITION TER VALUES (DEFAULT)
  );
 
 INSERT INTO APELLIDOS_MOY (NOM,EDAD) VALUES ('MOYANO',20);
 INSERT INTO APELLIDOS_MOY (NOM,EDAD) VALUES ('ROMERO',28);
 INSERT INTO APELLIDOS_MOY (NOM,EDAD) VALUES ('GARCIA',28);
 INSERT INTO APELLIDOS_MOY (NOM,EDAD) VALUES ('ZARAGALLO',26);
  
  
SELECT * FROM APELLIDOS_MOY;

SELECT * FROM APELLIDOS_MOY PARTITION (PRI);
SELECT * FROM APELLIDOS_MOY PARTITION (SEG);
SELECT * FROM APELLIDOS_MOY PARTITION (TER);
--SE METEN EN LA PARTICIÓN TERCERA LOS NOMBRES QUE NO SALEN EN LAS LISTAS. ESTO ES UTIL PARA EMPLEADOS...



-------EJERCICIO SIN LIST

DROP TABLE VENTAS_MOY PURGE;

CREATE TABLE VENTAS_MOY
(DNI NUMBER (9) CONSTRAINT PK_VENTAS_MOY_DNI PRIMARY KEY,
 NOM VARCHAR2 (20),
 FECHA_VENTA DATE
 )
 
 PARTITION BY RANGE (FECHA_VENTA)
 (PARTITION PRI_TRI VALUES LESS THAN (TO_DATE('01-04-2020','DD-MM-YYYY')),
  PARTITION SEG_TRI VALUES LESS THAN (TO_DATE('01-07-2020','DD-MM-YYYY')),
  PARTITION TER_TRI VALUES LESS THAN (TO_DATE('01-10-2020','DD-MM-YYYY')),
  PARTITION CUA_TRI VALUES LESS THAN (TO_DATE('01-01-2021','DD-MM-YYYY'))
  );
 
 INSERT INTO VENTAS_MOY VALUES (758475,'MOY','01-03-2020');
 INSERT INTO VENTAS_MOY VALUES (123654,'YOM','05-05-2020');
 INSERT INTO VENTAS_MOY VALUES (78548,'HUIJ','25-09-2020');
 INSERT INTO VENTAS_MOY VALUES (968574,'QWERTY','06-02-2020');
 INSERT INTO VENTAS_MOY VALUES (8574859,'QWERTY2','06-12-2020');

SELECT * FROM VENTAS_MOY;

SELECT * FROM VENTAS_MOY PARTITION (PRI_TRI);
SELECT * FROM VENTAS_MOY PARTITION (SEG_TRI);
SELECT * FROM VENTAS_MOY PARTITION (TER_TRI);
SELECT * FROM VENTAS_MOY PARTITION (CUA_TRI);

---------------------------------------RENOMBRAR PARTICOONES--------------------

ALTER TABLE VENTAS_MOY RENAME PARTITION CUA_TRI TO NUEVO_NOMBRE_PARTITION;

SELECT * FROM VENTAS_MOY PARTITION (NUEVO_NOMBRE_PARTITION);

ALTER TABLE VENTAS_MOY RENAME PARTITION NUEVO_NOMBRE_PARTITION TO CUA_TRI;

SELECT * FROM VENTAS_MOY PARTITION (CUA_TRI);


---------------------------------ELIMINAR UNA PARTICIÓN--------------------------

ALTER TABLE VENTAS_MOY DROP PARTITION (<NOMBRE_PARTICION>);

----------------------------------TRUNCAR PARTICIONES---------------------
--ME BORRA LOS DATOS PERO ME MANTIENE LA PARTICIÓN ***SI TRUNCAS TIENES QUE REPARAR EL INDICE, MIRAR MAS ABAJO***

ALTER TABLE VENTAS_MOY TRUNCATE PARTITION (<NOMBRE_PARTICION>);

--EJERCICIO

DROP TABLE VENTAS2_MOY PURGE;

CREATE TABLE VENTAS2_MOY
(DNI NUMBER PRIMARY KEY,
 NOM VARCHAR2(10)
)
PARTITION BY LIST(NOM)
 (PARTITION UNO VALUES ('PEPE', 'JOSE'),
  PARTITION DOS VALUES ('HOLA', 'ADIOS')
 );

INSERT INTO VENTAS2_MOY VALUES (1,'PEPE');
INSERT INTO VENTAS2_MOY VALUES (2,'ADIOS');

SELECT * FROM VENTAS2_MOY;

SELECT * FROM VENTAS2_MOY PARTITION (DOS);
SELECT * FROM VENTAS2_MOY PARTITION (UNO);


--PODEMOS ACTUALIZAR UNA TUPLA DE LA PARTICIÓN, SIEMPRE Y CUANDO LA PARTICIÓN O AFECTE A UNA PRIMARI KEY

--SI
UPDATE VENTAS2_MOY PARTITION (DOS)
 SET NOM = 'AIOS'
  WHERE DNI = 2;
  
--NO
UPDATE VENTAS2_MOY PARTITION (DOS)
 SET NOM = 'PEPE',
  WHERE DNI = 2;
  
--TRUNCAMOS LA PARTICIÓN

ALTER TABLE VENTAS2_MOY TRUNCATE PARTITION DOS;

INSERT INTO VENTAS2_MOY VALUES (3, 'PEPE'); --CASCA AHORA
INSERT INTO VENTAS2_MOY VALUES (4, 'HOLA'); --DA IGUAL LA PARTICIÓN, CASCA DESPUES DEL TRUNCATE

--HACEMOS UN STATUS PARA VER SU ESTADO
--DESPUES DE TRUNCATE LA TABLA CADA INUTILIZADA

SELECT STATUS FROM USER_INDEXES
 WHERE TABLE_NAME LIKE 'VENTAS2_MOY';
 
--COMPROVAMOS EL INDEX_NAME
SELECT USER_INDEXES.INDEX_NAME , STATUS FROM USER_INDEXES
 WHERE TABLE_NAME LIKE 'VENTAS2_MOY';

--TENEMOS QUE RECONSTRUIR EL INDICE CON:
ALTER INDEX SYS_C0011113 REBUILD;

--UNA VEZ REPARADO EL INDEX, YA PODEMOS VOLVER A INSERTAR TUPLAS
INSERT INTO VENTAS2_MOY VALUES (3, 'PEPE');
INSERT INTO VENTAS2_MOY VALUES (4, 'HOLA');

SELECT * FROM VENTAS2_MOY;

--PODEMOS GUARDAR EL REBUILD PARA QUE NO SE NOS OLVIDE DESPUES DE TRUNCAR CON <UPDATE GLOBAL INDEXES>

ALTER TABLE VENTAS2_MOY TRUNCATE PARTITION DOS UPDATE GLOBAL INDEXES;

--NO DA ERROR AHORA Y PODEMOS INSERTAR SIN PROBLEMAS.

INSERT INTO VENTAS2_MOY VALUES (3, 'PEPE');
INSERT INTO VENTAS2_MOY VALUES (4, 'HOLA');

SELECT * FROM VENTAS2_MOY;

--COMPROVAMOS EL INDEX Y COMPARAMOS
SELECT USER_INDEXES.INDEX_NAME , STATUS FROM USER_INDEXES
 WHERE TABLE_NAME IN ('CLIENTES','VENTAS2_MOY');
 


-------------------------------CORTAMOS Y PEGAMOS PARTICIONES----------------------------------
--CREAMOS UNA TABLA SIN PARTICIONAR, TAMBIEN PODRIA ESTAR PARTICIONADA, ESO DA IGUAL
DROP TABLE PARTEVENTAS_MOY PURGE;

CREATE TABLE PARTEVENTAS_MOY
(DNI NUMBER PRIMARY KEY,
 NOM VARCHAR2(10)
);
--COMPROVAMOS QUE VETNAS2_MOY TENGA TUPLAS EN LA PARTICIÓN
SELECT * FROM VENTAS2_MOY PARTITION (UNO);

--CORTAMOS LA PARTICIÓN DOS DE VENTAS2_MOY Y LA PEGAMOS EN LA TABLA PARTEVENTAS_MOY
ALTER TABLE VENTAS2_MOY EXCHANGE PARTITION UNO WITH TABLE PARTEVENTAS_MOY; --NO FUNCIONA UPDATE GLOBAL INDEXES;

--COMPROVAMOS QUE LOS DATOS EXISTEN, PERO NO SE PUEDEN MODIFICAR, ESTA UNUABLE
SELECT * FROM PARTEVENTAS_MOY;

--VEMOS CUAL ES EL ERROR DEL INDEX
SELECT USER_INDEXES.INDEX_NAME , STATUS FROM USER_INDEXES
 WHERE TABLE_NAME LIKE 'PARTEVENTAS_MOY';

--HACEMOS UN REUBILD DEL IDEX ERRONEO
ALTER INDEX SYS_C0011129 REBUILD;

--VOLVEMOS A COMPROBAR QUE YA NO ESTA UNUABLE, ESTA VALID

SELECT USER_INDEXES.INDEX_NAME , STATUS FROM USER_INDEXES
 WHERE TABLE_NAME LIKE 'PARTEVENTAS_MOY';
 
-----------------------------------------FUSIÓN DE PARTICIONES-----------------------------------------

ALTER TABLE VENTAS2_MOY MERGE PARTITIONS UNO, DOS INTO PARTITION UNO
      UPDATE GLOBAL INDEXES;

SELECT * FROM VENTAS2_MOY PARTITION (UNO);

SELECT * FROM VENTAS2_MOY PARTITION (DOS);--LA HEMOS BORRADO TOTALMENTE CON EL MERGE(FUSIÓN)

--ESTA EN INDEX VALID Y POR LO TANTO PODEMOS UTILIZAR SIN PROBLEMAS DML
SELECT USER_INDEXES.INDEX_NAME , STATUS FROM USER_INDEXES
 WHERE TABLE_NAME LIKE 'VENTAS2_MOY';
 

-------------------------------------------------OTROS SISTEMAS DE PARTICIONAMIENTO---------------------------------------
                         ---------------HASH------------------------
DROP TABLE VENTAS PURGE;

CREATE TABLE VENTAS
(DNI NUMBER PRIMARY KEY,
 NOM VARCHAR2 (30)
)
 PARTITION BY HASH (DNI) PARTITIONS 3;
 
 INSERT INTO VENTAS VALUES (1,'UNO');
 INSERT INTO VENTAS VALUES (3,'DOS');
 INSERT INTO VENTAS VALUES (3,'TRES');
 INSERT INTO VENTAS VALUES (4,'CUATRO');

--SACAMOS LOS NOMBRES DE LAS PARTITION
 SELECT * FROM USER_TAB_PARTITIONS
  WHERE TABLE_NAME LIKE 'VENTAS';

--COMPROBAMOS EN CUAL DE LAS PARTICIONES HA METIDO LAS TUPLAS. 
SELECT * FROM VENTAS PARTITION (SYS_P196);
SELECT * FROM VENTAS PARTITION (SYS_P197);
SELECT * FROM VENTAS PARTITION (SYS_P198); 

----------TAMBIEN PODEMOS ESPECIFICAR TABLESPACES

CREATE TABLE VENTAS
(DNI NUMBER PRIMARY KEY,
 NOM VARCHAR2 (30)
)
 PARTITION BY HASH (DNI)
 (PARTITION NOSE TABLESPACE USERS,
  PARTITION NOSE2 TABLESPACE USUDAW
  );
  
  
  
----------------------------------------------------------------------------------------
-------------------------------TIPOS DE PARTICIONAMIENTO: BY SYSTEM--------------------
----------------------------------------------------------------------------------------
--TIPO DE PARTICION SENCILLA Y PERO CON LIMITACIONES.

DROP TABLE TABLASYS PURGE;

CREATE TABLE TABLASYS
(DNI NUMBER PRIMARY KEY,
 NOM VARCHAR2(30)
 )
PARTITION BY SYSTEM
 (PARTITION UNA,
  PARTITION DOS,
  PARTITION TRES
  );
  
SELECT * FROM TABLASYS;

--CASCAN LOS INSTERT POR QUE ES TIPO SYSTEM
INSERT INTO TABLASYS VALUES (1,'UNO'); --NO SE PUEDEN SUPPARTICIONAR

--SI FUNCIONA ASI
INSERT INTO TABLASYS PARTITION (UNA) VALUES (1,'PEEP');

--                             ----------------0---------------------


----------------------------------SUBPARTICIONAMIENTO CONPOSITE------------------------------
DROP TABLE ESTUDIANTES PURGE;

CREATE TABLE ESTUDIANTES
(CEDULA VARCHAR(19) NOT NULL,
 NOMBRES VARCHAR(40),
 APELLIDOS VARCHAR(40),
 SEXO CHAR(1),
 ID_ESCUELA INTEGER,
 CONSTRAINT PK_ESTUDIANTES PRIMARY KEY (CEDULA)
)
PARTITION BY RANGE (ID_ESCUELA)
 SUBPARTITION BY HASH (SEXO)
              SUBPARTITION TEMPLATE
              (SUBPARTITION MASCULINO,
               SUBPARTITION FEMENINO
              )
              (PARTITION DOS VALUES LESS THAN (2) TABLESPACE USERS,
               PARTITION TRES VALUES LESS THAN (3) TABLESPACE USERS,
               PARTITION CUATRO VALUES LESS THAN (4) TABLESPACE USERS,
               PARTITION CINCO VALUES LESS THAN (MAXVALUE) TABLESPACE USERS
              );
              
INSERT INTO ESTUDIANTES VALUES('22-A','PEPE','PEREZ','H',1);         
INSERT INTO ESTUDIANTES VALUES('23-A','ANA','GARCIA','M',2);  
INSERT INTO ESTUDIANTES VALUES('24-A','JUAN','GONZÁLEZ','H',2);  
INSERT INTO ESTUDIANTES VALUES('25-A','SANTIAGO','LIRÓN','H',3);  
INSERT INTO ESTUDIANTES VALUES('26-A','TAMARA','SANCHÉZ','M',4);  
INSERT INTO ESTUDIANTES VALUES('27-A','ALBERTO','BUENDÍA','H',2);  
INSERT INTO ESTUDIANTES VALUES('28-A','EVA','PEREZ','M',1);  
INSERT INTO ESTUDIANTES VALUES('29-A','ALICIA','RAMOS','M',4);  
INSERT INTO ESTUDIANTES VALUES('30-A','CRISTIANO','RONALDO','H',1); 
INSERT INTO ESTUDIANTES VALUES('31-A','Y ESTE','A VER','H',13);

--PARA VER LAS PARTCIONES
 SELECT * FROM USER_TAB_PARTITIONS
  WHERE TABLE_NAME LIKE 'ESTUDIANTES';
 
--PARA VER LAS SUBPARTICIONES
 SELECT * FROM USER_TAB_SUBPARTITIONS
  WHERE TABLE_NAME LIKE 'ESTUDIANTES';
  
SELECT * FROM ESTUDIANTES;

SELECT * FROM ESTUDIANTES PARTITION (DOS);
SELECT * FROM ESTUDIANTES SUBPARTITION (DOS_MASCULINO);

--RENOMBRAR UNA SUBPARTICIÓN
ALTER TABLE ESTUDIANTES RENAME PARTITION DOS TO DOSBIS;

--DEJA LAS SUBPARTICIONES SIN TOCARLAS, PERO PARA DEJARLO CONCLUENTE DEBERIAMOS DE TAMBIER RENOMBRAR LAS SUBPARTICIONES

ALTER TABLE ESTUDIANTES RENAME SUBPARTITION DOS_MASCULINO TO DOSBIS_MASCULINO;
ALTER TABLE ESTUDIANTES RENAME SUBPARTITION DOS_FEMENINO TO DOSBIS_FEMENINO;


SELECT * FROM ESTUDIANTES PARTITION (DOSBIS);
SELECT * FROM ESTUDIANTES SUBPARTITION (DOSBIS_MASCULINO);
SELECT * FROM ESTUDIANTES SUBPARTITION (DOSBIS_FEMENINO);

-----TRUNCATE CON SUBPARTICIONES

---FOR
ALTER TABLE ESTUDIANTES TRUNCATE SUBPARTITION DOSBIS_MASCULINO;

SELECT USER_INDEXES.INDEX_NAME , STATUS FROM USER_INDEXES
 WHERE TABLE_NAME LIKE 'ESTUDIANTES';
 
ALTER INDEX PK_ESTUDIANTES REBUILD;

ALTER TABLE ESTUDIANTES TRUNCATE SUBPARTITION DOSBIS_MASCULINO UPDATE GLOBAL INDEXES;



--------------------EJERCICIO PRACTICO----------
DROP TABLE ALUMNOS_MOY PURGE;
DROP TABLE ALUMNOS_MOY;

--DROP TABLE IF EXISTS ALUMNOS_MOY CASCADE; NO SE SI SE PUEDE HACER.

CREATE TABLE ALUMNOS_MOY
(DNI NUMBER (9) CONSTRAINT PK_ALUMNOS_MOY_DNI PRIMARY KEY,
 NOMBRE VARCHAR2(30),
 SEXO VARCHAR2(1),
 CURSO NUMBER(1)
 )
 
 PARTITION BY LIST (CURSO)
    SUBPARTITION BY LIST (SEXO)
       SUBPARTITION TEMPLATE
       (SUBPARTITION HOMBRES VALUES ('h', 'H'),
        SUBPARTITION MUJERES VALUES ('m', 'M')
        )
 (PARTITION PRIMERO VALUES (1),
  PARTITION SEGUNDO VALUES (2),
  PARTITION TERCERO VALUES (3)
  )
  PARALLEL 4;
  
  INSERT INTO ALUMNOS_MOY VALUES (123456789, 'FULANITO', 'H', 3 );
  INSERT INTO ALUMNOS_MOY VALUES (234567891, 'MENGANITO', 'H', 1 );
  INSERT INTO ALUMNOS_MOY VALUES (345678912, 'ZARAGALLO', 'M', 2 );
  INSERT INTO ALUMNOS_MOY VALUES (456789123, 'RASCAPERSIANAS', 'M', 3 );
  
  SELECT * FROM ALUMNOS_MOY;
  
  SELECT * FROM ALUMNOS_MOY PARTITION (TERCERO);
  SELECT * FROM ALUMNOS_MOY SUBPARTITION (PRIMERO_HOMBRES);
  SELECT * FROM ALUMNOS_MOY SUBPARTITION (SEGUNDO_HOMBRES);
  
  SELECT * FROM USER_TAB_SUBPARTITIONS
  WHERE TABLE_NAME LIKE 'ALUMNOS_MOY';
  
  ALTER TABLE ALUMNOS_MOY ADD PARTITION CUARTO VALUES (4);


-------------------------------------------------------------------------------
-------------------------PAPELERA-----------------------------------------------

SELECT * FROM USER_RECYCLEBIN;
SELECT * FROM RECYCLEBIN;
PURGE RECYCLEBIN;

----------------COMO RECUPERAR UNA TABLA BORRADA
DROP TABLE ALUMNOS_MOY PURGE;
DROP TABLE ALUMNOS_MOY;


FLASHBACK TABLE ALUMNOS_MOY TO BEFORE DROP;

FLASHBACK TABLE ALUMNOS_MOY TO BEFORE DROP RENAME TO NUEVA_ALUMNOS_MOY;

  SELECT * FROM NUEVA_ALUMNOS_MOY;

ALTER TABLE NUEVA_ALUMNOS_MOY RENAME TO ALUMNOS_MOY;

  SELECT * FROM ALUMNOS_MOY;




--------------------------------------------------------------------------------
---------------------------------INTERVALOS-------------------------------------
-------------------------------------------------------------------------------

--SELECT  NUMTOYMINTERVAL (<VALOR_NUMERICO>,<YEAR/MONTH>) FROM DUAL;

SELECT NUMTOYMINTERVAL (1, 'MONTH') FROM DUAL;
SELECT NUMTOYMINTERVAL (3, 'YEAR') FROM DUAL;

--SELECT NUMTODSINTERVAL (<VALOR_NUMERICO>,<DAY/HOURS/MINUTE/SECOND>) FROM DUAL;

SELECT NUMTODSINTERVAL (22, 'DAY') FROM DUAL; --EL INTERVALO VA HA SER DE 22 DIAS
SELECT NUMTODSINTERVAL (88, 'MINUTE') FROM DUAL; --EL INTERVALO VA HA SER DE 88 MINUTOS



CREATE TABLE TRES
(N NUMBER PRIMARY KEY,
 NOM VARCHAR2(30),
 FECHA DATE
 )
 PARTITION BY RANGE (FECHA)
  INTERVAL (NUMTOYMINTERVAL (1, 'YEAR'))
  (PARTITION UNO VALUES LESS THAN (TO_DATE('1-1-2020', 'DD-MM-YYYY'))
  );
  
  SELECT * FROM USER_TAB_PARTITIONS
   WHERE TABLE_NAME LIKE 'TRES';
   
 INSERT INTO TRES VALUES (5,'MARCELINO PAN Y VINO', '12-12-2019');
 INSERT INTO TRES VALUES (2,'ZARAGALLO', '12-12-2020');
 INSERT INTO TRES VALUES (7,'FUTURE-MAN', '12-12-2030');
 INSERT INTO TRES VALUES (1,'FUTURE-MAN 2', '12-10-2019');
 
 SELECT * FROM TRES;
 
 ALTER TABLE TRES RENAME PARTITION SYS_P225 TO DOS;
 
 
 ------------------EJERCICIO TABLA POR MESES-----------
 DROP TABLE MESES_MOY PURGE;
 
 CREATE TABLE MESES_MOY
 (N NUMBER PRIMARY KEY,
  SEXO VARCHAR2(1),
  VENTAS NUMBER,
  MESES DATE
  )
  PARTITION BY RANGE (MESES)
     INTERVAL (NUMTOYMINTERVAL (1, 'MONTH'))
    SUBPARTITION BY LIST (SEXO)
      SUBPARTITION TEMPLATE
      (SUBPARTITION HOMBRES VALUES ('H', 'h'),
       SUBPARTITION MUJERES VALUES ('M', 'm')
       )
   (PARTITION UNO VALUES LESS THAN (TO_DATE('1-1-2020', 'DD-MM-YYYY'))
   );
   
   INSERT INTO MESES_MOY VALUES (1, 'H', 5000, '1-1-2020');
   INSERT INTO MESES_MOY VALUES (2, 'M', 8000, '1-2-2020');
   INSERT INTO MESES_MOY VALUES (3, 'H', 7000, '1-3-2020');
   INSERT INTO MESES_MOY VALUES (4, 'H', 10000, '1-4-2020');
   INSERT INTO MESES_MOY VALUES (5, 'M', 2000, '1-4-2020');
   
 --CAMBIAMOS EL NOMBRE DE LAS PARTICIONES (HAY QUE CAMBIAR LOS NOMBRES DE PARTICIONES CREADOS POR ORACLE)
 ALTER TABLE MESES_MOY RENAME PARTITION SYS_P252 TO DOS;
 ALTER TABLE MESES_MOY RENAME PARTITION SYS_P255 TO TRES;
 ALTER TABLE MESES_MOY RENAME PARTITION SYS_P258 TO CUATRO;
 
 --CAMIAMOS EL NOMBRE DE LAS SUBPARTICIONES (HAY QUE CAMBIAR LOS NOMBRES DE SUBPARTICIONES CREADOS POR ORACLE)
 ALTER TABLE MESES_MOY RENAME SUBPARTITION SYS_SUBP251 TO DOS_MUJERES;
 ALTER TABLE MESES_MOY RENAME SUBPARTITION SYS_SUBP250 TO DOS_HOMBRES;
 ALTER TABLE MESES_MOY RENAME SUBPARTITION SYS_SUBP254 TO TRES_MUJERES;
 ALTER TABLE MESES_MOY RENAME SUBPARTITION SYS_SUBP253 TO TRES_HOMBRES;
 ALTER TABLE MESES_MOY RENAME SUBPARTITION SYS_SUBP257 TO CUATRO_MUJERES;
 ALTER TABLE MESES_MOY RENAME SUBPARTITION SYS_SUBP256 TO CUATRO_HOMBRES;
 
 --COMPROBAMOS LAS CARACTERISTICAS DE LAS PARTICIONES DE LA TABLA
  SELECT * FROM USER_TAB_PARTITIONS
   WHERE TABLE_NAME LIKE 'MESES_MOY';
   
 --COMPROBAMOS LAS CARACTERISTICAS DE LAS SUBPARTICIONES DE LA TABLA   
  SELECT * FROM USER_TAB_SUBPARTITIONS
   WHERE TABLE_NAME LIKE 'MESES_MOY';
 
 --VEMOS LOS TOOOODOS LOS DATOS DE LA TABLA
 SELECT * FROM MESES_MOY;
 
 --VEMOS LOS DATOS DE LAS PARTICIONES Y SUBPARTICIONES
 SELECT * FROM MESES_MOY PARTITION (UNO);
 
 SELECT * FROM MESES_MOY SUBPARTITION (TRES_MUJERES);
 SELECT * FROM MESES_MOY SUBPARTITION (CUATRO_MUJERES);
 SELECT * FROM MESES_MOY SUBPARTITION (DOS_HOMBRES);
 
 
 
 ---------------------------EJRCICIOS---------------------------------------
 DROP TABLE ALUMNOS2_MOY;
 
 CREATE TABLE ALUMNOS2_MOY
 (DNI NUMBER PRIMARY KEY,
  CURSO VARCHAR2(1),
  IMPORTE NUMBER
  )
  
 PARTITION BY RANGE(IMPORTE)
  INTERVAL (500)
   SUBPARTITION BY LIST (CURSO)
    SUBPARTITION TEMPLATE
     (SUBPARTITION PRIMERO VALUES ('1'),
      SUBPARTITION SEGUNDO VALUES ('2')
      )
   (PARTITION UNO VALUES LESS THAN (500));
      

 INSERT INTO ALUMNOS2_MOY VALUES (123, '1',1000);
 INSERT INTO ALUMNOS2_MOY VALUES (321, '2',500);
 INSERT INTO ALUMNOS2_MOY VALUES (323, '1',300);



 SELECT * FROM ALUMNOS2_MOY;
 

 --INSERTAMOS UN COMENTARIO EN LA TABLA Y EN UNA COLUMNA
 COMMENT ON TABLE ALUMNOS2_MOY IS 'COMENTARIO ESPECIAL DE MOY';
 COMMENT ON COLUMN ALUMNOS2_MOY.DNI IS 'EL DNI DE LOS COLEGAS';
 
 --SACAMOS LOS NOMBRES DE TABLA_USER RELACIONADO CON LAS COLUMNAS
  SELECT * FROM DICT
 WHERE TABLE_NAME LIKE '%COMMEN%';
 
 --MOSTRAMOS LOS COMENTARIOS DE LA TABLA Y DE LAS COLUMNAS
 SELECT * FROM USER_TAB_COMMENTS
 WHERE TABLE_NAME LIKE 'ALUMNOS2_MOY';
 
  SELECT * FROM USER_COL_COMMENTS
 WHERE TABLE_NAME LIKE 'ALUMNOS2_MOY';
 
 
--------------------------------------------------------------- 
----------------------------STORORAGE--------------------------
----------------------------------------------------------------
--EL STORAGE CAMBIA LAS CARACTERISTICAS DE LA TABLA

--EJ.
     --CREATE TABLE.........
     --.....
     --) "FINAL DE LA TABLA"
     --TABLESPACE USERS
     --PARALLEL 4
     --STORAGE  (INITIAL 50K
     --          NEXT 20K
     --          MINEXTENTS 2
     --          PCTINCREASE 50
     --          ); --ESTO NUNCA SE PODRA CAMBIAR UNA VEZ CREADA LA TABLA
     
--------------------------------------------------------------- 
----------------------------COMENTARIOS--------------------------
----------------------------------------------------------------

--COMMENT ON TABLE <NOMBRE_TABLA> IS '<COMENTARIO>';                PARA CREAR COMENTARIO EN TABLA
--COMMENT ON TABLE <NOMBRE_TABLA> IS '';                            PARA ELIMINAR EL COMENTARIO
--COMMENT IN COLUMN <NOMBRE_TABLA>.<COLUMNA> IS '<COMENTARIO>'      PARA CREAR COMENTARIO EN COLUMNA


--COMO CONSULTAR LOS COMENTARIOS

    --PARA SABER CUAL ES EL NOMBRE DE BUSQUEDA DE LOS COMENTARIOS PODEMOS UTILIZAR ESTA FORMA
    -- %COMMEN% SE PUEDE CAMBIAR POR CUALQUIER COSA, COMO SI FUESE UN PATRON.
        --SELECT * FROM DICT
        --WHERE TABLE_NAME LIKE '%COMMEN%';
        

----------------------------------------------------------------------
---------------------INDEX-------------------------------------------
--------------------------------------------------------------------
--UN INDICE PARA UN ATRIBUTO QUE NO VA HA SER ÚNICO (PRIMARY_KEY) POR EJEMPLO PARA CURSO O CIUDAD
--A LA HORA DE HACER UNA CONSULTA PODEMOS BUSCAR CON ESE INDICE
--ADEMÁS PODEMOS PONER EL INDICE EN UN TABLESPACE DIFERENTE

--AL BORRAR LA TABLA SE BORRAN LOS INDICES CREADOS

--PARA CREAR EL INDICE
CREATE INDEX INDICE_MOY ON ALUMNOS2_MOY (CURSO ASC); 

--PARA BORRAR EL INDICE
DROP INDEX INDICE_MOY;

--PARA CONSULTAR LOS INDICES     
SELECT * FROM USER_INDEXES
 WHERE TABLE_NAME LIKE 'ALUMNOS2_MOY';        



----------------------------------------------------------------------------
-----------------------------SECUENCIAS-------------------------------------
----------------------------------------------------------------------------


--UTIL PARA CREAR UNA SECUENCIA EN UN ATRIBUTO, EL EJEMPLO SERIA LA SECUENCIA DE UN ATRIBUTO DE FACTURAS QUE 
--SE CREAR DE FORMA SECUENCIAL PARA QUE NO SE PUEDA REPETIR, CONFUNDIR, ETC.....

--CURVAL = VALOR ACTUAL SIN INCREMENTO
--NEXTVAL = VALOR ACTUAL MAS INCREMENTO

     --BORRAMOS LA SCUENCIA
DROP SEQUENCE SECPROFE;

     --CREAMOS LA SECUENCIA
CREATE SEQUENCE SECPROFE;

     --CONSULTAMOS LAS SECUENCIAS
SELECT * FROM USER_SEQUENCES;

     --VALORES DE MODIFICACIÓN DE LAS SECUENCIAS
ALTER SEQUENCE SECPROFE INCREMENT BY 2;
ALTER SEQUENCE SECPROFE INCREMENT BY 10 MAXVALUE 50;


DROP TABLE JJ PURGE;

CREATE TABLE JJ
(X NUMBER PRIMARY KEY,
 XX NUMBER
 );
 
 --AL CREAR INSERT VARIAS VECES NOS CREAR UN MONTON DE ATRIBUTOS X CORRELATIVOS
 INSERT INTO JJ VALUES (SECPROFE.NEXTVAL, 10);
 SELECT * FROM JJ;
 
 --COMO HEMOS PUESTO MAXVALUE 50 Y DE 10 EN 10 NO NOS DEJA CREAR MAS TUBPLAS
 DROP SEQUENCE SEC2;
 
 CREATE SEQUENCE SEC2 START WITH 10 INCREMENT BY -1 MAXVALUE 40 MINVALUE 0;
 
 INSERT INTO JJ VALUES (SEC2.NEXTVAL, 10);
 SELECT * FROM JJ;
 
 SELECT SEC2.CURRVAL FROM DUAL;
 
 
 --                      --------------------0----------------------------------
 
 ----------------------------------------------------------------------------------------
 ----------------------------------------CLUSTER-----------------------------------------
 ----------------------------------------------------------------------------------------
 
 --LA UNIDAD MINIMA DE ORACLE ES EL BLOQUE/CLUSTER
 
 --LIMITACIONES:
      --NO SE PUEDE COMPRIMIR
      --NO ADMITE ATRIBUTOS VIRTUALES
      --NO SE PUEDE PARTICIONAR
 
 --SINTAXIS:
      -- CREATE CLUSTER <NOMBRE_CLUSTER> (<NOMBRE_ATRIBUTO> <TIPO_ATRIBUTO>)
      -- TABLESPACE <NOMBRE_USUARIO_TABLESPACE>
      -- STORAGE .......(MIRAR STORAGE)
      -- SIZE...........(MIRAR SIZE)
      -- PARALLEL <NUMERO_DE_CPU`S>
      -- ;
 
 --PARA CREAR CLUSTER:
 
CREATE CLUSTER CLUSTER_MOY (ATRIBUTO1 NUMBER)
 TABLESPACE USERS
 STORAGE (INITIAL 100 K)
 SIZE 4
 PARALLEL 4;
 
 --PARA BORRAR CLUSTER:
 
 DROP CLUSTER CLUSTER_MOY;
 
 --CONSULTA DE CLUSTER
 
 SELECT * FROM USER_CLUSTERS;
 
 DROP TABLE UNA;
 CREATE TABLE UNA
 (X NUMBER PRIMARY KEY,
  XX CHAR
  )
  CLUSTER CLUSTER_MOY(X)
  ;
 
 
 DROP TABLE UNA2; 
   CREATE TABLE UNA2
 (X NUMBER PRIMARY KEY,
  XX CHAR
  )
  CLUSTER CLUSTER_MOY(X)
  ;
 --CLUSTER CLUSTER_MOY
 --CREATE INDEX UNA_MOY ON CLUSTER CLUSTER_MOY (X ASC);
 
-- CREATE INDEX UNA_MOY ON CLUSTER CLUSTER_MOY (X ASC);

--TENEMOS QUE CREAR EL INDEX ANTES DE PODER INSERTAR TUPLAS.
 CREATE INDEX UNA11_MOY
 ON CLUSTER CLUSTER_MOY
 TABLESPACE USERS;
 
 INSERT INTO UNA VALUES (1,'A');
  INSERT INTO UNA2 VALUES (1,'A');
   INSERT INTO UNA VALUES (2,'B');
  INSERT INTO UNA2 VALUES (2,'C');
   INSERT INTO UNA VALUES (3,'D');
  INSERT INTO UNA2 VALUES (3,'E');
 
 SELECT * FROM UNA;
 SELECT * FROM UNA2;
 
 SELECT * FROM UNA, UNA2
   WHERE UNA.X = UNA2.X;
   
 --NO PODEMOS BORRAR EL CLUSTER SIN BORRAR ANTERIORMENTE LAS TABLAS
 
 --PARA ESO UTILIZAMOS     INCLUDING 
 
 DROP CLUSTER CLUSTER_MOY INCLUDING TABLES;
 --ESTO BORRAR EL CLUSTER Y LAS TABLAS!!
 
 --EJERCICIO...VAMOS A AÑADIR EMPLE Y DEPART A UN CLUSTER
SELECT * FROM EMPLE;
SELECT * FROM DEPART;
 
 CREATE TABLE EMPLE_MOY
 (EMP_NO NUMBER PRIMARY KEY,
  APELLIDO VARCHAR2(30),
  OFICIO VARCHAR2(30)
  )
   CLUSTER CLUSTER_MOY(EMP_NO);
   
  CREATE TABLE DEPART_MOY
  (DEPT_NO NUMBER PRIMARY KEY,
   DNOMBRE VARCHAR(30),
   LOC VARCHAR2(30)
   )
   CLUSTER CLUSTER_MOY(DEPT_NO);
   
  CREATE INDEX INDICE_EMP_DEP_MOY ON CLUSTER CLUSTER_MOY;
  
  INSERT INTO EMPLE_MOY SELECT EMP_NO, APELLIDO, OFICIO FROM EMPLE;
  --MIRAR PRIMARY KEY DE EMPLE
  
  
 --------------------------------------------------------------------------------------------
 -------------------------------------SINONIMOS----------------------------------------------
 --------------------------------------------------------------------------------------------
 
 --SINTAXIS
 --CREATE [PUBLIC/PRIVATE] SYNONYM <NOMBRE>             *PRIVATE REQUIERE DERECHOS, PUBLIC NO
          --FOR TABLA......
             -- VISTA;;
 CREATE TABLE AVER_MOY AS SELECT * FROM AVER;
 
 GRANT ALL ON AVER TO ROL_DAW;
 
 SELECT * FROM AVER;
 
 CREATE PUBLIC SYNONYM AVER FOR PROFE.AVER;

 
 SELECT * FROM USER_SYNONYMS;
 SELECT * FROM ALL_SYNONYMS
 WHERE TABLE_NAME LIKE 'EMPLE';
  
 
 -----------------------------
 --DAR DERECHOS 
 --NO MATERIALICE
 --GRANT CREATE VIEW TO SCOTT;
 --MATERIALICE
 --GRANT CREATE MATERIALIZCE VIEW TO SCOTT;
 -----------------------------------------------------------------------------------------------
 -------------------------------------LISTAS-------------------------------------------------
 -------------------------------------------------------------------------------------------------
 
 --LISTAS {MATERIALIZADAS/NO MATERIALIZADAS}
 
 
 -------------------------------------------------------------------------
 --SINTAXIS DE NO MATERIALIZADAS (NO GASTAN STEND, MEMORIA)
 
 --CREATE [OR REPLACE] VIEW <NOMBRE> [COLUMNA  TIPO,COLUMNA 2   TIPO,....]
 --           AS
 --           SELECT................;
 DROP TABLE EMPLE_MOY;
 CREATE TABLE EMPLE_MOY AS SELECT * FROM EMPLE;
 
 CREATE OR REPLACE VIEW VISTA_MOY 
 AS SELECT APELLIDO, SALARIO, COMISION
 FROM EMPLE_MOY
 WHERE DEPT_NO IN (10,20);
 
 SELECT * FROM EMPLE_MOY;
 SELECT * FROM VISTA_MOY;
 
 --PARA VER QUE NO OCUPA ESPACIO
 SELECT * FROM USER_EXTENTS WHERE SEGMENT_NAME IN ('EMPLE_MOY', 'VISTA_MOY');
 SELECT * FROM USER_SEGMENTS WHERE SEGMENT_NAME IN ('EMPLE_MOY', 'VISTA_MOY');
 --PARA VER LAS LISTA
 SELECT * FROM USER_VIEWS;
 
 SELECT * FROM USER_OBJECTS WHERE OBJECT_TYPE LIKE 'VIEW';
 
 --UNA VISTA QUEDA INVALIDA CUANDO SE BORRA LA TABLA.
 --CREAMOS UNA COPIA DE EMPLE_MOY PRIMERO
 CREATE TABLE EMPLE_MOY_COPY AS SELECT * FROM EMPLE_MOY;
 
 --BORRAMOS EMPLE
 DROP TABLE EMPLE_MOY;
 
 --PROBAMOS SI SE VE LA VISTA Y COMPROBAMOS QUE NO
 SELECT * FROM VISTA_MOY;
  
 --VOLVEMOS A RECUPERAR LA TABLA DE LA PAPELERA
 FLASHBACK TABLE EMPLE_MOY TO BEFORE DROP;
 
 
 --SEGUIMOS VIENDO VISTAS
 
  CREATE OR REPLACE VIEW VISTA_MOY (APE, SAL, SUMA) 
 AS SELECT APELLIDO, SALARIO, COMISION + SALARIO --LOS ESPACIOS EN BLANCO NO SE PUEDEN PONER SIN UN ALIAS EN LOS ATRIBUTOS
 FROM EMPLE_MOY
 WHERE DEPT_NO IN (10,20);
 
 SELECT APE,SUMA FROM VISTA_MOY
 WHERE SUMA > 300000;
 
 SELECT * FROM EMPLE_MOY;
 SELECT * FROM VISTA_MOY;
 
               --------------------------------------------------
               
 --MANTENIMIENTO DE LA TABLA ORIGINAL A TRAVES DE LA VISTA (INSTERT, DELETE, ETC...)
 -- NO SE PODRA SI:
    --LAS SENNTECIAS NO SON SIMPLES.
    --LAS ATRIBUTOS NO ESTAN NOMBRADOS
    --LAS WHERE...NO COINCIDEN
    --LA VISTA NO TENGA DISTINT
    --LA VISTA CONTIENE WITH READ ONLY
 

  CREATE OR REPLACE VIEW VISTA_MOY 
 AS SELECT OFICIO, APELLIDO, SALARIO, COMISION
 FROM EMPLE_MOY
 WHERE DEPT_NO IN (10,20);

 
 SELECT * FROM VISTA_MOY;
 SELECT * FROM EMPLE_MOY;
 
 --NO FUNCIONA POR QUE OFICIO NO FORMA PARTE DE LA VISTA 
 UPDATE VISTA_MOY 
 SET EMP_NO = '1115'
     WHERE EMP_NO ='1142';   
 
 --ESTA SI FUNCIONA POR QUE ADEMAS DE ESTAR NOMBRADA EN LA VISTA, EL DEPT_NO DEL WHERE ES EL 20    
 UPDATE VISTA_MOY 
 SET OFICIO = 'PRESIDENTE'
     WHERE OFICIO='JEFE';  
     
 --SUBIR UN EURO A TODOS LOS EMPLEADOS 
 UPDATE VISTA_MOY
 SET SALARIO = SALARIO+1;
 --SOLO HA SUBIDO EL SALARIO A LOS EMPLEADOS DEL 10 Y DEL 20 QUE ESTAN SENTENCIADOS EN EL WHERE
 
 --OTRA VISTA
 DROP TABLE DEPART_MOY PURGE;
 
 CREATE TABLE DEPART_MOY AS SELECT * FROM DEPART;
 
 --CON DISTINCT NO PODEMOS HACER NINGUN TIPO CAMBIO
 CREATE OR REPLACE VIEW VISTA2_MOY
 AS SELECT DISTINCT DEPT_NO, LOC
 FROM DEPART_MOY;
 
  CREATE OR REPLACE VIEW VISTA3_MOY
 AS SELECT DEPT_NO, LOC
 FROM DEPART_MOY
 WITH READ ONLY;
 
 --COMO ANTERIORMETE SOLO PODREMOS INSERTAR EN LA TABLA SOLO SI CUMPLE CON LOS CRITERIOS BÁSICOS.
 
 --PARA VER LAS POSIBLES COLUMNAS QUE SE PUEDEN ACTUALIZAR
 SELECT * FROM DICT
  WHERE TABLE_NAME LIKE '%UPDATABLE%';
  
  SELECT * FROM USER_UPDATABLE_COLUMNS
  WHERE TABLE_NAME LIKE '%MOY%'
  AND
  UPDATABLE LIKE 'NO';
 
 ----------------------------------------------------------------
 
  --SINTAXIS DE MATERIALIZADAS (SI GASTAN STEND, MEMORIA)
 
 --CREATE MATERIALIZED VIEW <NOMBRE> [COLUMNA  TIPO,COLUMNA 2   TIPO,....]
 --       BUILD {<IMMEDIATE / DEFINED>}
 --       {NEVER REFRESH / (REFRESH{COOMPLETE / FAST / FORCE})}
 --       {(ON{COMMIT /DEMMAND}) / (STATE WITH ____ CONT____}
 --           AS
 --           SELECT................;
     SELECT * FROM PROFE.EMPLE2;
     SELECT * FROM PROFE.;
     DROP TABLE DEPART_MOY PURGE;
     DROP TABLE EMPLE_MOY PURGE;
CREATE TABLE EMPLE_MOY AS SELECT * FROM PROFE.EMPLE2;
CREATE TABLE DEPART_MOY AS SELECT * FROM PROFE.DEPART;

SELECT * FROM EMPLE_MOY;
SELECT * FROM MOY_VISTA;
SELECT * FROM VISTA;
SELECT * FROM EMPLE;
SELECT * FROM USER_MVIEWS;

DROP MATERIALIZED VIEW MOY_VISTA;


SELECT * FROM USER_SEGMENTS WHERE SEGMENT_NAME IN ('EMPLE', 'VISTA_MOY','MOY_VISTA');

INSERT INTO EMPLE_MOY VALUES(1112, 'UNO', 'PROGRAMA', 2222, SYSDATE, 200,100,10);

DELETE FROM EMPLE_MOY WHERE EMP_NO =1112;

--AL SER NEVER REFRESH NUNCA SE ACTUALIZA, ES COMO UNA COPIA PERO MEJOR
--BUILD IMMEDIATE (COPIA LA TABLA DE FORMA INMEDIATA CON TODOS LOS VALORES DE ESE INSTANTE)
CREATE MATERIALIZED VIEW MOY_VISTA
 BUILD IMMEDIATE
 NEVER REFRESH
 
 AS SELECT APELLIDO, SALARIO, LOC
 FROM EMPLE_MOY E
 INNER JOIN DEPART_MOY D
 ON E.DEPT_NO = D.DEPT_NO; 
 
 CREATE OR REPLACE VIEW VISTA
 AS SELECT APELLIDO, SALARIO, LOC
 FROM EMPLE_MOY E
 INNER JOIN DEPART_MOY D
 ON E.DEPT_NO = D.DEPT_NO; 
 
 --BUILD DEFERRED (SE CREA VACIA LA LISTA POR QUE ESTA NEVER REFRESH) Y SE 
 CREATE MATERIALIZED VIEW MOY_VISTA
 BUILD DEFERRED
 NEVER REFRESH
 AS SELECT APELLIDO, SALARIO, LOC
 FROM EMPLE_MOY E
 INNER JOIN DEPART_MOY D
 ON E.DEPT_NO = D.DEPT_NO; 
 
 --IMMEDIATE SIN NEVER REFRESH
 --REFRES COMPLETE ON....
 CREATE MATERIALIZED VIEW MOY_VISTA
 BUILD IMMEDIATE
 REFRESH COMPLETE ON DEMAND --SE ACTULIZARA A DEMANDA CON UN CODIGO
 AS SELECT APELLIDO, SALARIO, LOC
 FROM EMPLE_MOY E
 INNER JOIN DEPART_MOY D
 ON E.DEPT_NO = D.DEPT_NO;
  
 --REFRES COMPLETE ON....
 --CODIGO DE PARA ACTUALIZAR LA VISTA MATERIALIZADA
-- BEGIN 
--   DBMS_MVIEW.REFRESH('MOY_VISTA');
-- END;
 
  --REFRES COMPLETE ON....
  --IMMEDIATE SIN NEVER REFRESH
 CREATE MATERIALIZED VIEW MOY_VISTA
 BUILD IMMEDIATE
 REFRESH COMPLETE ON COMMIT --SE ACTUALIZA SIN EL CODIGO
 AS SELECT APELLIDO, SALARIO, LOC
 FROM EMPLE_MOY E
 INNER JOIN DEPART_MOY D
 ON E.DEPT_NO = D.DEPT_NO;
 
  --REFRES COMPLETE ON....
   --IMMEDIATE SIN NEVER REFRESH
 CREATE MATERIALIZED VIEW MOY_VISTA
 BUILD IMMEDIATE
 REFRESH COMPLETE ON COMMIT --SE ACTUALIZA SIN EL CODIGO
 AS SELECT APELLIDO, SALARIO, LOC
 FROM EMPLE_MOY E
 INNER JOIN DEPART_MOY D
 ON E.DEPT_NO = D.DEPT_NO;
 
  --REFRES COMPLETE START WITH....
  --REFRESCA CADA 20 SEGUNDOS
  
 CREATE MATERIALIZED VIEW MOY_VISTA
 BUILD IMMEDIATE
 REFRESH COMPLETE START WITH SYSDATE + 20 / (60*60*24) --CUANDO EMPIEZA
                  NEXT SYSDATE + 20 / (60*60*24)       --CADA CUANTO SE ACTUALIZA
 AS SELECT APELLIDO, SALARIO, LOC
 FROM EMPLE_MOY E
 INNER JOIN DEPART_MOY D
 ON E.DEPT_NO = D.DEPT_NO;
 
 --FUNCIONA CON DEFERED???
 
 CREATE MATERIALIZED VIEW MOY_VISTA
 BUILD DEFERRED
 REFRESH COMPLETE START WITH SYSDATE +8 / (60*60*24)
                  NEXT SYSDATE +8 / (60*60*24)
 AS SELECT APELLIDO, SALARIO, LOC
 FROM EMPLE_MOY E
 INNER JOIN DEPART_MOY D
 ON E.DEPT_NO = D.DEPT_NO;
 
 
 --LAS LISTAS FAST SOLO SE PODRAN HACER CON CONSULTAS SIMPLES, COMO LAS LISTA NO MATERIALIZADAS
 
  CREATE MATERIALIZED VIEW MOY_VISTA
 BUILD DEFERRED
 REFRESH FORCE ON DEMAND
 AS SELECT APELLIDO, SALARIO, LOC
 FROM EMPLE_MOY E
 INNER JOIN DEPART_MOY D
 ON E.DEPT_NO = D.DEPT_NO;
 
 
 
 
 ---REFRESH FAST ON COMMIT
 ALTER TABLE EMPLE_MOY ADD CONSTRAINT PK_EMPLE_MOY PRIMARY KEY (EMP_NO);
 
 --SOLO PODEMOS CREAR UN LOG POR TABLA
 CREATE MATERIALIZED VIEW LOG ON EMPLE_MOY
 WITH PRIMARY KEY INCLUDING NEW VALUES;
 
 --PARA BORRAR EL LOG
 DROP MATERIALIZED VIEW LOG ON EMPLE_MOY;
 
 
 CREATE MATERIALIZED VIEW MOY_VISTA
 BUILD IMMEDIATE
 REFRESH FAST ON COMMIT
 AS SELECT EMP_NO, APELLIDO, SALARIO, SALARIO + NVL(COMISION , 0) AS TOTAL
  FROM EMPLE_MOY;
  
 --AHORA NO SE ACTUALIZA HATA QUE NO COMMITEMOS, PERO ANTES VEMOS EL INDECE PARA EMPLE
 
 SELECT * FROM USER_MVIEW_LOGS;
 
 SELECT * FROM MLOG$_EMPLE_MOY;
 
 -----CREAR LA VISTA MATERIALIZADA SIN PRIMARY KEY EN TABLA BASE
 CREATE MATERIALIZED VIEW LOG ON EMPLE_MOY
 WITH ROWID INCLUDING NEW VALUES;
 
 CREATE MATERIALIZED VIEW MOY_VISTA
 BUILD IMMEDIATE
 REFRESH FAST ON COMMIT
 WITH ROWID
 AS SELECT EMP_NO, APELLIDO, SALARIO, SALARIO + NVL(COMISION , 0) AS TOTAL
 FROM EMPLE_MOY;
 
 --ON DEMMAND
 CREATE MATERIALIZED VIEW MOY_VISTA
 BUILD IMMEDIATE
 REFRESH FAST ON DEMAND
 WITH ROWID
 AS SELECT EMP_NO, APELLIDO, SALARIO, SALARIO + NVL(COMISION , 0) AS TOTAL
 FROM EMPLE_MOY;
 --CODIGO PARA DEMAND
 --BEGIN 
 -- DBMS_MVIEW.REFRESH('MOY_VISTA');
 --END;
 
 --FAST CON BUILD DEFERED
  
 CREATE MATERIALIZED VIEW MOY_VISTA
 BUILD DEFERRED
 REFRESH FAST ON DEMAND
 WITH ROWID
 AS SELECT EMP_NO, APELLIDO, SALARIO, SALARIO + NVL(COMISION , 0) AS TOTAL
 FROM EMPLE_MOY;
 --NO PUEDE FUNCIONAR POR QUE AL CREARSE CON NADA (DEFERRED) NUNCA PASA EL LOG A LA NUEVA TABLA.
 --DA IGUAL SI ESTA ON DEMAND, ON COMMIT, ON START....SIGUE SIN FUCINONA
 
 
 
 --PARA ACCEDER A LOS VALORES DE DE LA TABLA VISTA CON "EXPLAIN PLAN"
 CREATE MATERIALIZED VIEW MOY_VISTA
 BUILD IMMEDIATE
 REFRESH FORCE ON DEMAND
 ENABLE QUERY REWRITE
 AS SELECT APELLIDO, SALARIO, LOC
 FROM EMPLE_MOY E
 INNER JOIN DEPART_MOY D
 ON E.DEPT_NO = D.DEPT_NO;
 
 ALTER MATERIALIZED VIEW MOY_VISTA ENABLE QUERY REWRITE;
  ALTER MATERIALIZED VIEW MOY_VISTA DISABLE QUERY REWRITE;
  
  
  
---EJERCICIO_ VISTA MATERILIZADA CADA 20 SEGUNDOS MEDIAS DE SALARIOS POR OFICIOS 

 CREATE MATERIALIZED VIEW VISTA_EJERCICIO_EMPLE
 BUILD IMMEDIATE
 REFRESH COMPLETE START WITH SYSDATE + 20 / (60*60*24)
                  NEXT SYSDATE + 20 / (60*60*24)
 ENABLE QUERY REWRITE
 AS SELECT OFICIO, AVG(SALARIO)
 FROM EMPLE_MOY 
 GROUP BY OFICIO;
 
 SELECT * FROM VISTA_EJERCICIO_EMPLE; 
 
 
 
 
 
 
 
