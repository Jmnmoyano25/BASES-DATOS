--CREATE TABLE NOMBRE [SOLO ADMINTE _ Y $ COMO CARACTERES RAROS]
--CREATE TABLE NOMBRE
         --([NOMBRE CAMPO] [TIPO], 
         --         "        "   ,
         --         ......
         --) TABLESPACE[NOMBRE TABLESPACE CREADO Y CON ACCESO]; *SI NO PONES NADA COGE EL TABLESPACE POR DEFECTO.

--TIPO DE DATOS [TIPO]:

       --CARACTER:
       
          --CHAR = CHAR(1)
          --CHAR(10) = 2Kb
          --NCHAR(10) = 1Kb
          --VARCHAR(10) = 4Kb
          --VARCHAR2(10) = 4Kb
          --NVARCHAR2(10) = 2Kb
          --LONG  = 2Gb *DESFASADO, NO SE USA (SOLO PUEDE HABER UN LONG EN UNA TABLA)
          
       --NUMERICO:
       
          --INTEGER *REDONDEA AL ENTERO 
          --NUMBER
          --NUMBER(4) *HASTA 4 DIGITOS
          --NUMBER(6,2) *HASTA 4 ENTEROS Y 2 DECIMALES( 6-2 = 4)
          
       --BINARIOS: (IMAGENES, PDF, ETC...)
       
          --RAW = 2Kb          * DESFASADOS
          --LONG RAW = 2Gb     * DESFASADOS
          
          --LOB (FAMILIA DE TIPOS)
                --BFILE (ENLACE, PUNTERO, LINK, ETC...) NO SE GUARDA EL ARCHIVO EN ORACLE
                --BLOB = 4Gb SI SE GUARDA EL ARCHIVO EN LA TABLA DE ORACLE (EN BINARIO)
                --CLOB = 4Gb (CARACTER A CARACTER)
                
        --ROWID: (DIRECCION FISISCA DE UNA TUPLA)
           
          --000000(Nº SEGMENTO) FFF (Nº FICHERO) BBBBBB (Nº BLOQUE) XXX(Nº FILA)
          --000000FFFBBBBBBXXX
          
        --DATE: (7 DIGITOS: SIGLO, AÑO, MES, DIA, HORA, MINUTOS, SEGUNDO)
        
          --TIMESTAND (MAS DIGITOS, MAS ESPECIFICO)
          
  --USER__(CREADAS POR EL USUARIO)  TABLES
  --ALL__(CON ACCESO)               TABLES
  --DBA__(ADMINISTRADOR)            TABLES
  
  --USER__(CREADAS POR EL USUARIO)  OBJECT
  --ALL__(CON ACCESO)               OBJECT
  --DBA__(ADMINISTRADOR)            OBJECT
  
  --USER__(CREADAS POR EL USUARIO)  CATALOG
  --ALL__(CON ACCESO)               CATALOG
  --DBA__(ADMINISTRADOR)            CATALOG
  
--DROP PARA BORRAR TABLAS, OBJETOS

--DELETE PARA BORRAR TUBPLAS

--ALTER SESSION (PARA GUARDAR EL FORMATO EN UNA "VARIABLE" PARA LA SESION )
          
CREATE TABLE PROBANDO
 (
 NOMBRE VARCHAR2(4000),
 EDAD NUMBER(5,2),
 FECHA DATE
 );
 
SELECT * FROM USER_TABLES
WHERE TABLE_NAME='PROBANDO';

SELECT * FROM USER_OBJECTS;
SELECT * FROM USER_CATALOG;

INSERT INTO PROBANDO VALUES ('MOYANO',555.666, '02 12 2019');
INSERT INTO PROBANDO VALUES ('MOY',34.666444444,TO_DATE('13 VIERNES 12 2019', 'DD DAY MM YYYY'));
INSERT INTO PROBANDO VALUES ('MOY',658.666444444,TO_DATE('13 VIERNES 12 2019 22:34:20', 'DD DAY MM YYYY HH24:MI:SS'));

ALTER SESSION SET NLS_DATE_FORMAT = 'DD DAY MM YYYY HH24:MI:SS';

INSERT INTO PROBANDO VALUES ('MOY',58.666, '14 VIERNES 01 2019');

SELECT * FROM PROBANDO;

DROP TABLE PROBANDO;




SELECT * FROM USER_TABLES;

--PRIMARY KEY
--CRETATE TABLE 
          --(C1 TIPO[CONSTANT------] PRIMARY KEY


DROP TABLE NOSE1;

CREATE TABLE NOSE1
(NOMBRE VARCHAR2(10),
 DNI VARCHAR2(10) CONSTRAINT PK_NOSE1 PRIMARY KEY,
 SALDO NUMBER
)TABLESPACE USUDAW;

INSERT INTO NOSE1 VALUES ('PEPE','11-b',4);
INSERT INTO NOSE1 VALUES ('MARIA','11-b',6);--DA ERROR AL DUPLICAR DATOS EN DNI
INSERT INTO NOSE1 VALUES ('JUAN','11-H',6);
SELECT * FROM NOSE1;

SELECT * FROM USER_TABLES;

SELECT * FROM USER_CONSTRAINTS
 WHERE TABLE_NAME LIKE 'NOSE1';
 
 
 
 
--PRIMARY KEY COMPARTIDA ENTRE DOS ATRIBUTOS
 
DROP TABLE NOSE2;
 
CREATE TABLE NOSE2
(NOMBRE VARCHAR2(10),
 FACTURA NUMBER,
 CLIENTE NUMBER,
 CONSTRAINT PK_NOSE2 PRIMARY KEY(FACTURA,CLIENTE)
)TABLESPACE USUDAW;
 
INSERT INTO NOSE2 VALUES ('PEPE','11',4);
INSERT INTO NOSE2 VALUES ('MARIA','16',8);
INSERT INTO NOSE2 VALUES ('JUAN','11',9);
--SE PUEDEN REPETIR ATRIBUTOS POR QUE COMPARTEN EL PRIMARY KEY

SELECT * FROM NOSE2;

SELECT * FROM USER_TABLES;

--PARA VER TODOS LOS CANSTRAINT DE LAS TABLAS
SELECT * FROM USER_CONS_COLUMNS
 WHERE TABLE_NAME LIKE 'NOSE2';
 



--UNIQUE

DROP TABLE NOSE3;
 
CREATE TABLE NOSE3
(NOMBRE VARCHAR2(10) CONSTRAINT U_NOMBRE_NOSE3 UNIQUE,
 FACTURA NUMBER,
 CLIENTE NUMBER,
 CONSTRAINT PK_NOSE3 PRIMARY KEY(FACTURA,CLIENTE)
)TABLESPACE USUDAW;
 
INSERT INTO NOSE3 VALUES ('PEPE',1,10);
INSERT INTO NOSE3 VALUES ('PEPE',1,11);
INSERT INTO NOSE3 (FACTURA,CLIENTE) VALUES (2,10);



SELECT * FROM NOSE3;

SELECT * FROM USER_TABLES;

SELECT * FROM USER_CONSTRAINTS;




--DEFAULT

DROP TABLE MOY1;
 
CREATE TABLE MOY1
(NOMBRE VARCHAR2(10) CONSTRAINT U_NOMBRE_MOY1 UNIQUE,
 FACTURA NUMBER,
 CLIENTE NUMBER,
 FECHA DATE DEFAULT SYSDATE,
 USUARIO VARCHAR2(30) DEFAULT USER,
 CIUDAD VARCHAR2(20) DEFAULT 'ALCALA DE HENARES',
 CONSTRAINT PK_MOY1 PRIMARY KEY(FACTURA,CLIENTE)
)TABLESPACE USUDAW;
 
INSERT INTO MOY1 VALUES ('JUAN', 1,1,'12 12 2020', 'USUARIO_A', 'MURCI');
INSERT INTO MOY1 (NOMBRE,FACTURA,CLIENTE) VALUES ('PEDRO', 2,2);
INSERT INTO MOY1 (NOMBRE,FACTURA,CLIENTE) VALUES ('MARIA', 3,3);


SELECT * FROM MOY1;

SELECT * FROM USER_TABLES;

SELECT * FROM USER_CONSTRAINTS;



--CHECK (TRUE, FALSE O NULL)[TRUE ADMITE TUPLA, FALSE O NULL NO LA ADMITE]
       --NO ADMITE SYSDATE, USER, Y OTRAS

DROP TABLE MOY1;
 
CREATE TABLE MOY1
(NOMBRE VARCHAR2(10) CONSTRAINT C_NOMBRE_MOY1 CHECK (NOMBRE LIKE 'A%' AND LENGTH(NOMBRE)>= 8),
 FACTURA NUMBER,
 CLIENTE NUMBER,
 CONSTRAINT PK_MOY1 PRIMARY KEY(FACTURA,CLIENTE)
)TABLESPACE USUDAW;
 
INSERT INTO MOY1 VALUES ('JUAN', 1,1);--SOLO ADMITE NOMBRES QUE EMPIEZEN POR A____ Y QUE SEAN MAYORES O IGUALES A 8 CARACTERES
INSERT INTO MOY1 VALUES ('ALBERTITO', 1,1);



SELECT * FROM MOY1;

SELECT * FROM USER_TABLES;

SELECT * FROM USER_CONSTRAINTS;



--NOMBRE, SALARIO Y COMISION (SALARIO MAS COMISION MAS DE 200 Y EL NOMBRE EN MAYUSCULAS)
DROP TABLE MOY1;
 
CREATE TABLE MOY1
(NOMBRE VARCHAR2(10) CONSTRAINT C_NOMBRE_MOY1 CHECK (NOMBRE = UPPER(NOMBRE)),
 CORREO VARCHAR2(30) CONSTRAINT C_CORREO_MOY1 CHECK (CORREO LIKE '%@.%'),
 SALARIO NUMBER, 
 COMISION NUMBER,
 CONSTRAINT C_SALARIO_MOY1 CHECK ((SALARIO + NVL(COMISION,0)) < 200)
)TABLESPACE USUDAW;
 
INSERT INTO MOY1 VALUES ('JUAN','JU@.JIJI', 100,50);
INSERT INTO MOY1 VALUES ('alberto','JU@.JIJI', 20,150);--SOLO ADMITE NOMBRES EN MAYUSCULAS
INSERT INTO MOY1 VALUES ('PEPE','JU@.JIJI', 150,150);--SOLO ADMITE SALARIO + COMISION MENOR A 200


SELECT * FROM MOY1;

SELECT * FROM USER_TABLES;

SELECT * FROM USER_CONSTRAINTS;

--CONSTRAINT 

CREATE TABLE NN
       (COD NUMBER CONSTRAINT PK_NN PRIMARY KEY INITIALLY IMMEDIATE,
        NUM NUMBER
        ) TABLESPACE USUDAW;
INSERT INTO NN VALUES (1,10);

CREATE TABLE NN
       (COD NUMBER CONSTRAINT PK_NN PRIMARY KEY INITIALLY IMMEDIATE,
        NUM NUMBER
        ) TABLESPACE USUDAW;
INSERT INTO NN VALUES (1,10);
COMMIT WORK;--SE POSTERGA LA VALIDACIÓN



--.......PRIMARY KEY........
CREATE TABLE NN
       (COD NUMBER CONSTRAINT PK_NN PRIMARY KEY,
        NOM VARCHAR2 (30),
        NUM NUMBER PRIMARY KEY
        ) TABLESPACE USUDAW;--CASCA, NO PUEDE HACERSE DOS PRIMARY KEY ASI

CREATE TABLE MOY2
       (COD NUMBER,
        NOM VARCHAR2 (30),
        NUM NUMBER,
        CONSTRAINT PK_MOY2 PRIMARY KEY (COD,NOM) INITIALLY DEFERRED
        ) TABLESPACE USUDAW;--ASI SI SE HACEN VARIAS PRIMARY KEY
        
INSERT INTO MOY2 VALUES (1, 'PEPE', 20);
INSERT INTO MOY2 VALUES (1, 'JUAN', 20);
INSERT INTO MOY2 VALUES (2, 'PEPE', 20);
INSERT INTO MOY2 VALUES (1, 'JUAN', 260);
COMMIT WORK;

SELECT * FROM MOY2;

SELECT * FROM USUER_TAB_COLS
WHERE TABLE_NAME LIKE 'MOY2';

DROP TABLE MOY2;


--NUMERO OBLIGATORIO PERO NO PK (NOT NULL)

CREATE TABLE MOY2
       (COD NUMBER,
        NOM VARCHAR2 (30),
        NUM NUMBER CONSTRAINT V_MOY2 NOT NULL INITIALLY DEFERRED,
        CONSTRAINT PK_MOY2 PRIMARY KEY (COD,NOM) INITIALLY DEFERRED
        ) TABLESPACE USUDAW;
        
INSERT INTO MOY2 VALUES (1, 'PEPE', 2);
INSERT INTO MOY2 VALUES (1, 'JUAN', 2);
INSERT INTO MOY2(COD,NOM) VALUES (1, 'ANA');

--CHECK

CREATE TABLE MOY2
       (COD NUMBER CONSTRAINT C_CODIGO CHECK (COD IN (1,2,3)),
        NOM VARCHAR2 (30),
        NUM NUMBER CONSTRAINT V_MOY2 NOT NULL INITIALLY DEFERRED,
        CONSTRAINT PK_MOY2 PRIMARY KEY (COD,NOM) INITIALLY DEFERRED
        ) TABLESPACE USUDAW;
        
 INSERT INTO MOY2 VALUES (1, 'PEPE', 5);--CHUTA
 INSERT INTO MOY2 VALUES (4, 'PEPE', 5);--NO CHUTA
 
 
--EJERCICIO.
--QUE VALIDE UN CORREO ELECTRONICO QUE TENGA UNA @ Y UN .
CREATE TABLE MOY2
       (CORREO VARCHAR (30) CONSTRAINT C_CORREO CHECK (CORREO LIKE ('%_@_%.%')),
        NOM VARCHAR2 (30),
        NUM NUMBER CONSTRAINT V_MOY2 NOT NULL INITIALLY DEFERRED,
        CONSTRAINT PK_MOY2 PRIMARY KEY (CORREO,NOM) INITIALLY DEFERRED
        ) TABLESPACE USUDAW;
        
 INSERT INTO MOY2 VALUES ('JUAN@JI.IJ', 'PEPE', 5);--CHUTA
 INSERT INTO MOY2 VALUES ('JUA@.IJ', 'PEPE', 5);--CASCA
 INSERT INTO MOY2 VALUES ('@YHY.IJ', 'PEPE', 5);--CASCA
 INSERT INTO MOY2 VALUES ('PEPE', 5);--CASCA
 
 SELECT * FROM MOY2;--CHUTA
 
 --DOS RESTRICCIONES EDAD ( ENTRE 20 Y 40) Y OFICIO (VENDEDORES, COMERCIALES, GERENTES) Y CIUDAD
 
 CREATE TABLE MOY3
        (NUM NUMBER,
         EDAD NUMBER CONSTRAINT C_EDAD CHECK (EDAD BETWEEN 20 AND 30),
         OFICIO VARCHAR2 (30) CONSTRAINT C_OFICIO CHECK (OFICIO IN ('VENDEDORES', 'COMERCIALES', 'GERENTES')INITIALLY DEFERRED,)
         CIUDAD VARCHAR2 (20) DEFAULT 'ALCALA DE HENARES'
         );
         
 INSERT INTO MOY3 VALUES (1,30,'VENDEDOR', 'TERUEL');
 INSERT INTO MOY3 VALUES (1,300,'VENDEDOR', 'TERUEL');--CASCA
 INSERT INTO MOY3 VALUES (1,30,'NOSE', 'TERUEL');--CASCA




--...........TABLAS RELACIONADAS.............

CREATE TABLE CLIENTE
       (DNI NUMBER CONSTRAINT PK_CLIENTE PRIMARY KEY,
        NOM VARCHAR2 (30)
        );


CREATE TABLE FACTURA
       (COD_F NUMBER CONSTRAINT PK_FACTURA PRIMARY KEY,
        COD_C NUMBER CONSTRAINT FK_FACTURA_CLIENTE REFERENCES CLIENTE(DNI),
        IMPORTE NUMBER
        );
        
INSERT INTO CLIENTE VALUES (10,'SANCHEZ');  
INSERT INTO CLIENTE VALUES (20,'JUAREZ');    
INSERT INTO FACTURA VALUES (1,10,200);--CASCA SIN EL INSERT EN CLIENTE

SELECT * FROM CLIENTE;
SELECT * FROM FACTURA;

DROP TABLE CLIENTE;
DROP TABLE FACTURA;

--NO PODEMOS CREAR FACTURA ANTES QUE CLIENTE, TAMPOCO PODEMOS BORRAR CLIENTE ANTES QUE FACTURA POR QUE ESTA PERTENECE A CLIENTE.

--PARA HACER BORRADO EN CASCADA (CLIENTE-FACTURA)....CASCADE CONSTRAINT
SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME IN ('CLIENTE','FACTURA');

DROP TABLE CLIENTE CASCADE CONSTRAINT;

--DELETE EN CASACADA
DROP TABLE CASCADA;
DROP TABLE FACTURA11;


CREATE TABLE CASCADA
(COD NUMBER PRIMARY KEY,
 NOM VARCHAR2 (30)
 );
 
CREATE TABLE FACTURA11
(NUM NUMBER PRIMARY KEY,
 COD NUMBER REFERENCES CASCADA(COD) ON DELETE CASCADE,
 TOTAL NUMBER
 );

INSERT INTO CASCADA VALUES (1, 'UNO');
INSERT INTO CASCADA VALUES (2,'DOS');

INSERT INTO FACTURA11 VALUES (10,1,40);
INSERT INTO FACTURA11 VALUES (11,1,50);
INSERT INTO FACTURA11 VALUES (12,2,40);

DELETE FROM CASCADA WHERE COD=1; --NO SE PUEDE BORRAR PORQUE FACTURA11 DEPENDE DE CASCADA

--PERO CON DELETE CASCADE SI SE PUEDE, AHORA YA LAS REFERENCIAS A CASCADA (FOREY KEY) YA NO EXISTEN, PEREO SI SU DATOS.
--HAY QUE INCLUIRLO EN LA CREACION DE LA TABLA HIJA.
DELETE FROM CASCADA WHERE COD=1;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME LIKE 'FACTURA11';
SELECT * FROM CASCADA;
SELECT * FROM FACTURA11;



--HASTA AHORA HEMOS VISTO ATRIBUTOS REALES (GASTAN ESPACIO)

--ATRIBUTOS VIRTUALES( NO GASTSTAN ESPACIO)

--SINTAXIS: NOM-A [TIPO] GENERATE ALWAYS AS <EXPRESION> VIRTUAL

CREATE TABLE MOY3
       (COD NUMBER CONSTRAINT PK_OTRA PRIMARY KEY,
       SALARIO NUMBER,
       COMISION NUMBER,
       TOTAL NUMBER GENERATED ALWAYS AS (COMISION + SALARIO) VIRTUAL,
       FECHA DATE
       );
       
INSERT INTO MOY3 (COD, SALARIO, COMISION, FECHA)
       VALUES (1,20,40,SYSDATE);
       
INSERT INTO MOY3 (COD, SALARIO, COMISION, FECHA)
       VALUES (2,60,400,'12/12/2050');
       
INSERT INTO MOY3
       VALUES (1,20,40,60,SYSDATE);--CASCA PORQUE AUNQUE EL VALOR VIRTUAL ES CORRECTO (20 + 40 = 60), ESTOS NO ADMITEN VALORES.
  

SELECT * FROM MOY3;

SELECT * FROM USER_SEGMENTS
       WHERE SEGMENT_NAME LIKE 'MOY3';

SELECT * FROM USER_TAB_COLS
       WHERE TABLE_NAME LIKE 'MOY3';
      

--**LLEVAR A CREACION DE TABLAS (TRUNCATE)
--SINTAXIS:
--         TRUNCATE TABLE <NOMBRE_TABLE> [DROP/REUSE]STRORAGE
--REUSE: BORRA LAS TUPLAS Y REUTILIZA LOS ESPACIOS DEL TABLESPACE
--DROP: BORRA LAS TUPLAS Y ADEMÁS LIBERA LOS STEN/CELDAS/ESPACIOS
DROP TABLE MOY4;

CREATE TABLE MOY4
(N CHAR(2000));
SELECT COUNT(*) FROM MOY4;

TRUNCATE TABLE MOY4 REUSE STORAGE;
TRUNCATE TABLE MOY4 DROP STORAGE;

SELECT * FROM USER_SEGMENTS
       WHERE SEGMENT_NAME LIDE 'MOY4';


--COPIAR DEL SU ARCHIVO PARA TERMINAR EL EJERCICIO.

--OTRO EJERCICIO DE TRUNCATE

CREATE TABLE DATOS
(COD NUMBER,
 DES VARCHAR2 (40),
 DECO GENERATED ALWAYS AS (DECODE (DES, 'MESA', 'M',
                                        'SILLA', 'S',
                                        'TABURETE','T',
                                        DES
                                   ) || '-' || LENGTH (DES)
                           ) VIRTUAL
);

INSERT INTO DATOS (COD,DES) VALUES (1,'MESA');
INSERT INTO DATOS (COD,DES) VALUES (2,'NOSE');
INSERT INTO DATOS (COD,DES) VALUES (3,'SILLA');
INSERT INTO DATOS (COD,DES) VALUES (4,'TABURETE');

SELECT * FROM DATOS;



--OTRO EJERCICIO 


CREATE TABLE CUENTA_MOY
(DNI NUMBER CONSTRAINT PK_CUENTA_MOY PRIMARY KEY,
 NOM VARCHAR2(30),
 CCC VARCHAR2(20),                           --CON PONER UNICAMENTE LA CCC NOS DESGLOSA ESTA EN LAS VIRTUALES CON SUBSTR
 ENTIDAD GENERATED ALWAYS AS (SUBSTR(CCC,1,4)) VIRTUAL,
 SUCURSAL GENERATED ALWAYS AS (SUBSTR(CCC,5,4)) VIRTUAL,
 DD GENERATED ALWAYS AS (SUBSTR(CCC,9,2)) VIRTUAL,
 CUENTA GENERATED ALWAYS AS (SUBSTR(CCC,11,10)) VIRTUAL
 );
 
INSERT INTO CUENTA_MOY(DNI,NOM,CCC)
       VALUES (1,'UNO', '11110000550123456789');
INSERT INTO CUENTA_MOY(DNI,NOM,CCC)
       VALUES (2,'DOS', '99995555449876543210');
INSERT INTO CUENTA_MOY(DNI,NOM,CCC)
       VALUES (3,'TRES', '66668888775678901234');
       
SELECT * FROM CUENTA_MOY



--EJERCICIO TABLAS HOSPITAL

CREATE TABLE HOSPITAL1
(HOSPITAL_COD NUMBER 
  



---------------------------------------------CREANDO TABLAS PROCEDENTES DE UNA SELECT----------------------------------------

--CREATE TABLE <NOMBRE[(ATRIBUTO,ATRIBUTO,......)]
         --[TABLEESPACE ____]
         --AS
         --SELECT * FROM <NOMBRE TABLA OBJETIVO>
                  --WHERE........
 
--UTIL PARA COPIAR DATOS DE OTRAS TRABLAS

--TABLA ORIGEN DEL PROFE        
SELECT * FROM PROFE.EMPLE2;

--TABLA NUEVA MIA
CREATE TABLE EMPLEMOY
       --TABLEESPACE USUDAW
       AS
       SELECT * FROM PROFE.EMPLE2;
       
SELECT * FROM EMPLEMOY;
DROP TABLE EMPLEMOY;

--TAMBIEN SE PUEDE COPIAR SOLO LOS ATRIBUTOS QUE NECESITE Y CON OTROS NOMBRES
CREATE TABLE EMPLEMOY (APE, SAL, COMM)
       AS
       SELECT APELLIDO, SALARIO, COMISION
       FROM PROFE.EMPLE2;
SELECT * FROM EMPLEMOY;

DROP TABLE EMPLEMOY;
--COPIAR CON LOS NOMBRES ORIGINALES
CREATE TABLE EMPLEMOY 
       AS
       SELECT APELLIDO, SALARIO, COMISION
       FROM PROFE.EMPLE2;
SELECT * FROM EMPLEMOY;

DROP TABLE EMPLEMOY;

--LAS CONSTRAINT NO SE COMPIAN
--SOLO SE COPIAN LAS CONSTRAIN QUE NO TENGAN NOMBRE Y LAS PK Y LAS FK NO SE COPIAN DE NINGUNA MANERA
SELECT * FROM USER_CONSTRAINTS
       WHERE TABLE_NAME IN ('PROFE.EMPLE2');
       
--COPIAMOS TABLAS PARA COMPARAR CONSTRAINS

--CREAMOS UNA TABLA RAMDOM....
DROP TABLE PRIMERA;
CREATE TABLE PRIMERA
(DNI NUMBER CONSTRAINT PK_PRIMERA_DNI PRIMARY KEY,
 X NUMBER NOT NULL,
 XX NUMBER CONSTRAINT C_SS CHECK (XX BETWEEN 1 AND 100)
 );

--COPIAMOS LA TABLA PRIMERA RAMDOM
DROP TABLE COPIAPRIMERA;
CREATE TABLE COPIAPRIMERA 
       AS
       SELECT * FROM PRIMERA;
       
SELECT * FROM USER_CONSTRAINTS
       WHERE TABLE_NAME IN ('PRIMERA', 'COPIAPRIMERA');
--PODEMOS COMPROBAR QUE LAS CONSTRAINS NO SE HAN COPIADO.



-------------------------------------MODIFICACIÓN DE TABLES-------------------------------------------------
--ALTER TABLE
        --[VARIOS FORMATOS
                  --....
                  --....
                  --....
                  --....]
DROP TABLE MODIFICAR;

CREATE TABLE MODIFICAR
(NUM NUMBER(5),
 NOM VARCHAR2(10)
 );
-----------------AÑADIMOS UNA COLUMNA O VARIAS, Y PODEMOS PONER LA CONSTRAINT 
ALTER TABLE MODIFICAR ADD (EDAD NUMBER);
ALTER TABLE MODIFICAR ADD (DNI NUMBER CONSTRAINT PK_MODIFICAR_DNI PRIMARY KEY, FECHA DATE);

-----------------BORRAMOS COLUMNAS
ALTER TABLE MODIFICAR DROP (FECHA, NOM);

--INSERTAMOS DATOS
INSERT INTO MODIFICAR VALUES(1,2,548587);

-----------------NO SE PUEDE AÑADIR COLUMNAS DESPUES DE AÑADIR DATOS, TIENE QUE ESTAR VACIA
INSERT INTO MODIFICAR VALUES(1, 'UNO');
ALTER TABLE MODIFICAR ADD(X NUMBER NOT NULL);--CASCA

------------------SE PUEDE HACER LO ANTERIOR HACIENDO EL CAMPO OBLIGATORIO CON CHECK
ALTER TABLE MODIFICAR ADD(X NUMBER CONSTRAINT C_NULO CHECK (X IS NOT NULL));
ALTER TABLE MODIFICAR ADD(Y NUMBER CHECK (Y IS NOT NULL));

INSERT INTO MODIFICAR VALUES (2,'DOS', 20, 1);
INSERT INTO MODIFICAR (NUM,NOM) VALUES (3,'TRES');--CASCA POR QUE NECESITA QUE X E Y SEAN OBLIGATORIAS

--------------------PARA AÑADIR UNA PRIMARY KEY YA CREADA....
INSERT INTO MODIFICAR VALUES(1, 'UNO');
ALTER TABLE MODIFICAR ADD (DNI NUMBER PRIMARY KEY);--NO SE PUEDE COMO ANTERIORMETE (NOT NULL)
      --SE HACE ASI
ALTER TABLE MODIFICAR ADD (DNI NUMBER CHECK (DNI IS NOT NULL)UNIQUE);

INSERT INTO MODIFICAR VALUES (2, 'DOS', 10);

---------------------PODEMOS MODIFICAR CON MODIFY
--SIN DATAS SE MODIFICA FACILMENTE
ALTER TABLE MODIFICAR MODIFY (NUM NUMBER(3), NOM VARCHAR2(12));

--CON DATOS ES DIFERENTE
INSERT INTO MODIFICAR VALUES(12345, 'UNOTGTR');

--CON LAS CADENAS SOLO SE PUEDE REDUCIR EL TAMAÑO HASTA EL LIMITE SIN MODIFICAR LOS DATOS
--CON LOS NUMBER SOLO SE PUEDEN AMPLIAR LOS DATOS
ALTER TABLE MODIFICAR MODIFY (NOM VARCHAR2(7));
ALTER TABLE MODIFICAR MODIFY (NOM VARCHAR2(5));--CASCA POR QUE NUM TINE MAS DE 5 CARACTERES
ALTER TABLE MODIFICAR MODIFY (NUM NUMBER (10));
ALTER TABLE MODIFICAR MODIFY (NUM NUMBER (4));--CASCA POR QUE LOS NUMBER NO SE PUEDEN REDUCIR

--TAMBIEN PODEMOS MODIFICAR LAS CONSTRAINS CON MODIFY
ALTER TABLE MODIFICAR MODIFY (NUM NUMBER(5) CONSTRAINT PK_MODIFICAR_NUM PRIMARY KEY);

--CON DATOS NO PODEMOS AÑADIR 
INSERT INTO MODIFICAR VALUES(1, 'UNO');
INSERT INTO MODIFICAR VALUES(2, 'DOS');

---------------------------------------CONSTRAINT-------------------------------------------
---------------------------------PODEMOS AÑADIR CONSTRAINT SIN MODIFY CON ADD---------------------------------------
       DROP TABLE NOSE3000;
       
CREATE TABLE NOSE3000
(X NUMBER,
 XX NUMBER
 );

ALTER TABLE NOSE3000 ADD CONSTRAINT PK_NOSE3000_X PRIMARY KEY(X);

------------------------------------------NO PODEMOS AÑADIR DEFAUL CON ADD PERO SI CON MODIFY

ALTER TABLE NOSE3000 ADD CONSTRAINT D_NOSE3000_X DEFAULT 0;--CASCA
ALTER TABLE NOSE3000 MODIFY (XX NUMBER DEFAULT 0); --CON MODIFY SI PODEMOS POR QUE MODIFICAMOS TODO EL ATRIBUTO

SELECT * FROM MODIFICAR;

------------------------------------------PODEMOS BORRAR CONSTRAINT CON DROP

SELECT * FROM USER_CONS_COLUMNS
        WHERE TABLE_NAME LIKE 'NOSE3000';

ALTER TABLE NOSE3000 DROP CONSTRAINT PK_NOSE3000_X;

SELECT * FROM USER_CONS_COLUMNS
        WHERE TABLE_NAME LIKE 'NOSE3000';
    
--LOS DATOS SE MANTIENEN, SOLO SE BORRA EL ATRIBUTO CONTRAINT

--------------------------------------PODEMOS ACTIVAR O DESACTIVAR LAS CONSTRAINT
          DROP TABLE NOSE3000;

CREATE TABLE NOSE3000
(X NUMBER CONSTRAINT C_NOSE CHECK (X IN(1,2,4)),
 XX NUMBER
 );
 
 INSERT INTO NOSE3000 VALUES (1,2);
 INSERT INTO NOSE3000 VALUES (3,44); --NO SE PERMITE MIETRAS LA CONSTRAINT ESTE ACTIVA
 
 SELECT * FROM NOSE3000;
 
 SELECT * FROM USER_CONS_COLUMNS
        WHERE TABLE_NAME LIKE 'NOSE3000'; 

ALTER TABLE NOSE3000 DISABLE CONSTRAINT C_NOSE;

SELECT * FROM USER_CONS_COLUMNS
        WHERE TABLE_NAME LIKE 'NOSE3000'; 
     
 
----------------PARA BUSCAR LA RESTRICCION QUE SE INCUMPLE--------------------
--CREAMOS TABLA
          DROP TABLE FALLO;

CREATE TABLE FALLO
(FILA ROWID,
 USU VARCHAR2 (40),
 TABLA VARCHAR2 (40),
 CUAL VARCHAR2 (40)
 );
--LEVANTAMOS LA CONSTRAINT
ALTER TABLE NOSE3000 ENABLE CONSTRAINT C_NOSE EXCEPTIONS INTO FALLO; 

--
SELECT X, ROWID
FROM NOSE3000;

--COMPARAMOS LOS DATOS ENTRE TABLAS PARA VER EL DATO QUE FALLO PARA PODER LEVANTAR LA RESTRICCION
SELECT * FROM NOSE3000, FALLO
WHERE NOSE3000.ROWID = FALLO.FILA;
--ACATUALIZAMOS LA TABLA PARA ARREGLAR EL ERROR, EL 3 
UPDATE NOSE3000
SET X = 2
WHERE XX = 44;

TRUNCATE TABLE FALLO;

SELECT * FROM FALLO;

--1º CREAMOS LA TABLA NOSE3000
--2º AÑADIMOS DATOS
--3º LEVANTAMOS LA CONSTRAINT: ---ALTER TABLE NOSE3000 DISABLE CONSTRAINT C_NOSE;
--4º ANADIMOS DATOS SIN RESTRINCCION:  INSERT INTO NOSE3000 VALUES (3,44);
--5º CREAMOS TABLA FALLO
--6º LEVANTAMOS LA CONSTRAINT CON EXECPTION PARA LLENAR LA TABLA FALLO CON SUS EXECPIONES: --ALTER TABLE NOSE3000 ENABLE CONSTRAINT C_NOSE EXCEPTIONS INTO FALLO; 
--7º COMPARAMOS LOS DATOS ENTRE TABLAS PARA VER EL DATO QUE FALLO PARA PODER LEVANTAR LA RESTRICCION:
--              SELECT * FROM NOSE3000, FALLO
--              WHERE NOSE3000.ROWID = FALLO.FILA;
--8º ACATUALIZAMOS LA TABLA PARA ARREGLAR EL ERROR, EL 3
--9º TRUNCAMOS LA TABLA FALLO PARA QUITAR LOS DATOS DEL ERROR
--10º VOLVEMOS A LEVANTAR LA RESTRICCION: --ALTER TABLE NOSE3000 ENABLE CONSTRAINT C_NOSE EXCEPTIONS INTO FALLO;
--11º COMPROVAMOS LA TABLA NOSE3000:  --SELECT * FROM NOSE3000;


--EJEMPLO
CREATE TABLE NOSE3000
(X NUMBER,
 XX NUMBER
 );
 ALTER TABLE NOSE3000 MODIFY (X NUMBER CONSTRAINT PK_NOSE3000_X PRIMARY KEY);
 
 SELECT * FROM USER_CONS_COLUMNS
        WHERE TABLE_NAME LIKE 'NOSE3000';
        
--OTRA FORMA DE SACAR LA INFO CORRUPTA ES CON UNA TABLA SOLO LECTURA 

          DROP TABLE NOSE3000;

CREATE TABLE NOSE3000
(X NUMBER CONSTRAINT C_NOSE CHECK (X IN(1,2,4)),
 XX NUMBER
 );
 
 INSERT INTO NOSE3000 VALUES (1,2);
 
 --HACEMOS LA TABLA A SOLO LECTURA
 ALTER TABLE NOSE3000 READ ONLY ;
 
 SELECT * FROM NOSE3000;
 
 SELECT * FROM USER_TABLES 
 WHERE TABLE_NAME LIKE 'NOSE3000'; --EN READ ONLY ESTA EN YES
 
 --PASAMOS LA TABLA A ESCRITURA
ALTER TABLE NOSE3000 READ WRITE;

 SELECT * FROM USER_TABLES 
 WHERE TABLE_NAME LIKE 'NOSE3000'; --EN READ ONLY ESTA EN NO
 
 
 
 
 
 ------------------------------------TABLAS COMPRIMIDAS-------------------------------------------------
 ------------------------------EL ACCESO ES MÁS RAPIDO SI ESTA COMPRIMIDO.
                             --TABLAS COMPRIMIDAS:     
                                  --ACCESO A LOS DATOS MAS LENTO
                                  --NUMERO DE BLOQUES MUCHO --MENOR--
                             --TABLAS NORMALES:     
                                  --ACCESO A LOS DATOS MAS RÁPIDO
                                  --NUMERO DE BLOQUES MUCHO --MAYOR--

-------SINTAXIS                                 
--CREATE TABLE <NOMBRE>
--(<ATRIBUTO 1>
--[ATRIBUTO 2]
--[........]
--)[TABLESPACE <NOMBRE>]
--[COMPRESS]
--[COMPRESS FOR ALL OPERATIONS]
--[COMPRESS FOR OMPT]

--NOMBRE:
-- NC = NO COMPRIMIDAD
-- CB = COMPRESION BÁSICA
-- C1 = COMPRESION PRIMERA
CREATE TABLE NC
(X CHAR(20),
XX CHAR(20)
)TABLESPACE USUDAW;

CREATE TABLE CB
(X CHAR(20),
XX CHAR(20)
)COMPRESS TABLESPACE USUDAW;

CREATE TABLE C1
(X CHAR(20),
XX CHAR(20)
)COMPRESS FOR ALL OPERATIONS;

SELECT TABLE_NAME, COMPRESSION, COMPRESS_FOR
FROM USER_TABLES
WHERE TABLE_NAME IN ('NC', 'CB', 'C1');

--SANTIAGO RELLENA LAS TABLAS CON 500000 TUPLAS
SELECT COUNT(*) FROM PROFE.NC;
SELECT COUNT(*) FROM PROFE.CB;
SELECT COUNT(*) FROM PROFE.C1;

--ESTO ES PARA VER LOS BLOQUES DE LAS TABLAS Y COMPROBAR QUE C1 ES MEJOR COMPRESION QUE CB
SELECT SEGMENT_NAME, BLOCKS, ROUND (BYTES/1024/1024,2) MEGAS
FROM USER_SEGMENTS
WHERE SEGMENT_NAME IN ('PROFE.NC', 'PROFE.CB', 'PROFE.C1');

--------------------PODEMOS HACER CASI CUALQUIER ACCIÓN CON ALTER TABLE, PERO EN C1, EN CB ES MÁS LIMITADO
--BORRAMOS COLUMAS, EN CB NO SE PUEDE
ALTER TABLE CB DROP (XX);

--PERO EN C1 SI SE PUEDE
ALTER TABLE C1 DROP (XX);

-----------------------QUITAMOS LA COMPRESION CON NOCOMPRESS Y PODEMOS VOLVER A COMPRIMIRLAS
ALTER TABLE CB NOCOMPRESS;
ALTER TABLE C1 NOCOMPRESS;
ALTER TABLE CB COMPRESS;
ALTER TABLE C1 COMPRESS FOR ALL OPERATIONS;

SELECT TABLE_NAME, COMPRESSION, COMPRESS_FOR
FROM USER_TABLES
WHERE TABLE_NAME IN ('NC', 'CB', 'C1');

INSERT INTO CB VALUES ((SELECT 'V' FROM DUAL), 'X');

ALTER TABLE CB COMPRESS FOR ALL OPERATIONS;

--TODOS LOS CAMBIOS CON ALTER TABLE SOLO ES EFECTIVO PARA LAS NUEVAS TUPLAS.
--LAS TUPLAS ANTERIORES A LOS CAMBIOS SE QUEDAN CON SU VERSIÓN ANTERIOR.

ALTER TABLE CB COMPRESS;

--CON MOVE PASO LAS TUPLAS NUEVAS Y TAMBIEN LAS VIEJAS. MUY IMPORTANTE.
ALTER TABLE CB MOVE COMPRESS FOR ALL OPERATIONS;

ALTER TABLE CB READ ONLY;



------------------------------------TABLAS TEMPORALES--------------------------------------------
--NO SOPORTA PARTICIONAMIENTO
--NO SOPORTA COMPRESIÓN
--NO SOPORTA TABLESPACE


--LAS TUPLAS SE BORRAN DE DOS FORMAS:
     --POR CIERRE DE SESIÓN
     --POR COMMIT O ROLLBACK
     
--SINTAXIS
--


CREATE GLOBAL TEMPORARY TABLE SANCHEZ
(X NUMBER CONSTRAINT PK_SANCHEZ PRIMARY KEY,
XX VARCHAR2 (10)
);

INSERT INTO SANCHEZ VALUES (1,'PP');

SELECT * FROM SANCHEZ;


--LAS TABLAS NO GENERAN REDOLOG (LOGGING), ES DECIR, SI RESTAURAS SISTEMA, PIERDES LOS DATOS DE LA TABLA.
SELECT * FROM USER_TABLES
WHERE TABLE_NAME IN ('NOSE3000', 'SANCHEZ');


--PODEMOS COMPARTIR UNA TABLA ENTRE USUARIOS
--GRANT ALL ON SANCHEZ TO ROL_DAW;

INSERT INTO PROFE.SANCHEZ VALUES (56,'VV');
INSERT INTO PROFE.SANCHEZ VALUES (89,'DoD');

SELECT * FROM PROFE.SANCHEZ;


--CON COMMIT RESERVE ROWS, AUNQUE COMITEMOS LAS TUPLAS SE MANTIENEN
CREATE GLOBAL TEMPORARY TABLE IGLESIAS
(X NUMBER PRIMARY KEY,
 XX VARCHAR2 (10)
) ON COMMIT PRESERVE ROWS;

INSERT INTO IGLESIAS VALUES (1,'FEO');
INSERT INTO IGLESIAS VALUES (5,'MALO');
SELECT * FROM IGLESIAS;
COMMIT WORK;--NO SE BORRAN
-- SE BORRAN CUANDO CERRAMOS LA SESIÓN
INSERT INTO IGLESIAS VALUES (4,'BUENO');
--EL ROLLBACK FUNCIONA COMO ESPERAMOS, 
INSERT INTO IGLESIAS VALUES (7,'LA CHICA');

INSERT INTO PROFE.IGLESIAS VALUES (1,'FEO');
INSERT INTO PROFE.IGLESIAS VALUES (5,'MALO');
SELECT * FROM PROFE.IGLESIAS;

INSERT INTO PROFE.IGLESIAS VALUES (4,'BUENO');
--EL ROLLBACK FUNCIONA COMO ESPERAMOS, 
INSERT INTO IGLESIAS VALUES (7,'LA CHICA');




-----------------------------CONSULTAS PARALELAS----------------------------------------
--------POR CONSULTA/INSTRUCCION
--------POR SESIÓN
--------POR TABLA

-----------POR CONSULTA--------------------
--ALTER SYSTEM FLUSH SAHRED_POOL;

--SELECT /*+ PARALLEL(4) */ * FROM EMPLE;
--SELECT * FROM EMPLE;

--ALIAS (<ALIAS>,<N1 DE NUCLEOS DE LA MAQUINA>)
--SELECT /*+ PARALLEL(E,4) */ APELLIDO FROM EMPLE E;
--SELECT /*+ PARALLEL (E,4) PARALLEL(D,4) */
         --APELLIDO, LOC
         --FROM EMPLE E
         --INNER JOIN DEPART D
         --ON E.DEPT_NO = D.DEPT_NO;
 

----------------POR SESION------------------------        
--PARALELAJE PARA QUERY, DML, DDL


--SOLO PARA CONSULTAS DE CUALQUIER TABLA
ALTER SESSION ENABLE PARALLEL QUERY;

--PARA TODO MENOS SELECT
ALTER SESSION ENABLE PARALLEL DML;

--PARA CREAR TABLAS, ETC...
--PARA DML SOLO FUNCIONA SI LAS TABLAS ESTAN PARTICIONADAS
ALTER SESSION ENABLE PARALLEL DDL;

--PARA DESACTIVAR
ALTER SESSION DISABLE PARALLEL QUERY;


--CON ESTO FIJAMOS LOS CORES PARA TODA LA SESSION
--ESTO VALE TANTO PARA QUERY COMO PARA DML Y DLL.
ALTER SESSION FORCE PARALLEL QUERY PARALLEL 4;


--------------------POR TABLA------------------------------------
--PODEMOS DEFINIR LOS CORES POR TABLA
--ALTER TABLE <NOMBRE DE LA TABLA> PARALLEL <Nº DE CORES>;
--ALTER TABLE <NOMBRE DE LA TABLA> PARALLEL (DEGREEE <Nº DE CORES>);
ALTER TABLE CUENTA_MOY PARALLEL 2;

SELECT TABLE_NAME, DEGREE FROM USER_TABLES
  WHERE TABLE_NAME IN ('CUENTA_MOY', 'NOSE3');

--PARA DEJAR TODAS LAS TABLAS EN NUCLES POR DEFECTO

--DEGREE DEFAULT

ALTER TABLE CUENTA_MOY NOPARALLEL;


--------------------------------------------------------------------------------------------
------------------------------------TABLAS EXTERNAS-----------------------------------------
--------------------------------------------------------------------------------------------

--NO GASTAN EXTEND
--NO PODEMOS PONER RESTRICCIONES

CREATE TABLE EXTERNA
(DEP NUMBER, 
 SALDO NUMBER(12,2),
 LOC VARCHAR2 (20),
 DNOMBRE VARCHAR2 (30),
 FECHA DATE
 )
 ORGANIZATION EXTERNAL
 (TYPE ORACLE_LOADER DEFAULT DIRECTORY FICHEROS
 ACCESS PARAMETERS (RECORDS DELIMITED BY NEWLINE
                    SKIP O
                    FIELDS TERMINATED BY ','
                    MISSING FIELD VALUES ARE NULL
                            (DEP INTEGER EXTERNAL(2),
                             SALDO FLOAT EXTERNAL(12),
                             LOC CHAR (20),
                             DNOMBRE CHAR (30),
                             FECHA CHAR (10) DATE_FORMAT DATE MASK "DD-MM-YYYY"
                             )
                    )
 LOCATION ('tata1.TXT')
 );
 
 
 
 ------------------------------------------------------------------------------------------
 --                                PARTICIONAMIENTO
 ------------------------------------------------------------------------------------------
 
 --RANGO
 
 --CREAMOS UNA TABLA Y LA PARTICIONAMOS
 
 --PUEDE ESTAR EN DIFIRENTES TABLESPACES, DISCOS, ETC...
 
 
--PARA VER EL TABLESPACE
SELECT * FROM USER_USERS;
 
DROP TABLE ESTUDIANTES PURGE;  --PURGE LA ELIMINA TAMBIEN DE LA PAPELERA
 
CREATE TABLE ESTUDIANTES
(DNI NUMBER CONSTRAINT PK_ESTUDIANTES_DNI PRIMARY KEY,
 NOM VARCHAR2 (30),
 EDAD NUMBER,
 CURSO NUMBER
 )
 --PODEMOS CAMBIAR LOS TABLESPACES (SON IGUALES AHORA POR QUE NO TENEMOS ACCESO A MÁS)
 PARTITION BY RANGE(CURSO)
 (PARTITION UNO VALUES LESS THAN (2) TABLESPACE USUDAW,
  PARTITION DOS VALUES LESS THAN (3) TABLESPACE USUDAW,
  PARTITION TRES VALUES LESS THAN (4) TABLESPACE USUDAW,
  PARTITION CUATRO VALUES LESS THAN (5)  TABLESPACE USUDAW,
  PARTITION ERRORES VALUES LESS THAN (MAXVALUE) --SE SUELE HACER UNA PARTICIÓN CAJON DESASTRE PARA LOS DATOS ERRORES.
  )COMPRESS;--PODEMOS COMPRIMIRLA

INSERT INTO ESTUDIANTES VALUES (10, 'DIEZ',10,2);
INSERT INTO ESTUDIANTES VALUES (12, 'DOCE',10,3);
INSERT INTO ESTUDIANTES VALUES (14, 'CATORCE',10,1);
INSERT INTO ESTUDIANTES VALUES (16, 'DIECISEIS',10,2);
INSERT INTO ESTUDIANTES VALUES (18, 'DIECIOCHO',10,3);
INSERT INTO ESTUDIANTES VALUES (20, 'VEINTE',10,4);
INSERT INTO ESTUDIANTES VALUES (22, 'VEINTIDOS',10,5);

 
SELECT * FROM ESTUDIANTES;


--PARA SACAR SOLAMENTE LOS DEL CURSO 1

SELECT * FROM ESTUDIANTES
 WHERE CURSO = 1;
 
--CON PARTITION MUCHO MÁS RÁPIDO Y SIN WHERE

SELECT * FROM ESTUDIANTES PARTITION (UNO);
SELECT * FROM ESTUDIANTES PARTITION (DOS);
SELECT * FROM ESTUDIANTES PARTITION (TRES);
SELECT * FROM ESTUDIANTES PARTITION (ERRORES);


SELECT * FROM USER_TABLES
WHERE TABLE_NAME IN ('EMPLE', 'ESTUDIANTES');

SELECT * FROM USER_EXTENTS
WHERE SEGMENT_NAME IN ('EMPLE', 'ESTUDIANTES');


SELECT * FROM USER_SEGMENTS
WHERE SEGMENT_NAME IN ('EMPLE', 'ESTUDIANTES');

SELECT * FROM USER_TAB_PARTITIONS
WHERE TABLE_NAME LIKE 'ESTUDIANTES';





---------------PARTICIONES POR STRINGS Y CLAVES VIRTUALES POR PARTICIONAMIENTO


DROP TABLE ESTUDIANTES_2 PURGE;  --PURGE LA ELIMINA TAMBIEN DE LA PAPELERA
 
CREATE TABLE ESTUDIANTES_2
(NIF VARCHAR2(9) CONSTRAINT PK_ESTUDIANTES_2_NIF PRIMARY KEY,
 LETRA GENERATED ALWAYS AS (SUBSTR(NIF,LENGTH (NIF),1)) VIRTUAL,
 EDAD NUMBER
 )
 --PODEMOS CAMBIAR LOS TABLESPACES (SON IGUALES AHORA POR QUE NO TENEMOS ACCESO A MÁS)
 PARTITION BY RANGE(LETRA)
 (PARTITION UNO VALUES LESS THAN ('H') TABLESPACE USUDAW,
  PARTITION DOS VALUES LESS THAN ('M') TABLESPACE USUDAW,
  PARTITION TRES VALUES LESS THAN ('P') TABLESPACE USUDAW,
  PARTITION CUATRO VALUES LESS THAN ('Z')  TABLESPACE USUDAW,
  PARTITION CINCO VALUES LESS THAN (MAXVALUE)  TABLESPACE USUDAW
 -- PARTITION ERRORES VALUES LESS THAN ( ) --SE SUELE HACER UNA PARTICIÓN CAJON DESASTRE PARA LOS DATOS ERRORES.
  )COMPRESS;--PODEMOS COMPRIMIRLA

INSERT INTO ESTUDIANTES_2 (NIF,EDAD) VALUES ('51997678X',10);
INSERT INTO ESTUDIANTES_2 (NIF,EDAD) VALUES ('997678G',10);
INSERT INTO ESTUDIANTES_2 (NIF,EDAD) VALUES ('51997678Z',10);
INSERT INTO ESTUDIANTES_2 VALUES ('51997678A',10);
INSERT INTO ESTUDIANTES_2 VALUES ('51997678X',10);


 
SELECT * FROM ESTUDIANTES_2;

SELECT * FROM ESTUDIANTES PARTITION (UNO);
SELECT * FROM ESTUDIANTES PARTITION (DOS);
SELECT * FROM ESTUDIANTES PARTITION (TRES);
SELECT * FROM ESTUDIANTES_2 PARTITION (CINCO);

SELECT * FROM USER_TAB_PARTITIONS;

--ACTUALIZAR UNA PARTICIÓN

UPDATE ESTUDIANTES_2
 SET EDAD = 3
  WHERE NIF = '51997678X';
  
UPDATE ESTUDIANTES_2
 PARTITION (UNO)
  SET EDAD = 8
  WHERE NIF = '997678G';
  
--PATICIÓN POR APELLIDOS DE UNA TABLA, PERO SE PUEDE HACER SIN EL SUBSTR Y LO COGE IGUAL (MIRAR APUNTES SANTIAGO)

DROP TABLE APELLIDOS_MOY PURGE;

CREATE TABLE APELLIDOS_MOY
 (NOM VARCHAR2(20) CONSTRAINT PK_APELLIDOS_MOY_NOM PRIMARY KEY,
  APE VARCHAR2(20) GENERATED ALWAYS AS (SUBSTR (NOM,1,1)) VIRTUAL,
  EDAD NUMBER
  )
  
 PARTITION BY RANGE (APE)
 (PARTITION PRI VALUES LESS THAN ('H'),
  PARTITION SEG VALUES LESS THAN ('M'),
  PARTITION TER VALUES LESS THAN ('Z'),
  PARTITION CUAR VALUES LESS THAN (MAXVALUE)
  );
 
 INSERT INTO APELLIDOS_MOY (NOM,EDAD) VALUES ('MOYANO',20);
 INSERT INTO APELLIDOS_MOY (NOM,EDAD) VALUES ('ROMERO',28);
 INSERT INTO APELLIDOS_MOY (NOM,EDAD) VALUES ('GARCIA',28);
 INSERT INTO APELLIDOS_MOY (NOM,EDAD) VALUES ('ZARAGALLO',26);
  
  
SELECT * FROM APELLIDOS_MOY;


----------------------------------PARTICIÓN POR LISTA--------------------------------------------------



CREATE TABLE APELLIDOS_MOY
 (NOM VARCHAR2(20) CONSTRAINT PK_APELLIDOS_MOY_NOM PRIMARY KEY,
  APE VARCHAR2(20) GENERATED ALWAYS AS (SUBSTR (NOM,1,1)) VIRTUAL,
  EDAD NUMBER
  )
  
 PARTITION BY LIST (APE) -----LIST
 (PARTITION PRI VALUES ('C', 'D', 'H', 'L'),----NO SE PONE LESS THAN
  PARTITION SEG VALUES ('O', 'R', 'V', 'Z'),
  PARTITION TER VALUES (DEFAULT)
  );
 
 INSERT INTO APELLIDOS_MOY (NOM,EDAD) VALUES ('MOYANO',20);
 INSERT INTO APELLIDOS_MOY (NOM,EDAD) VALUES ('ROMERO',28);
 INSERT INTO APELLIDOS_MOY (NOM,EDAD) VALUES ('GARCIA',28);
 INSERT INTO APELLIDOS_MOY (NOM,EDAD) VALUES ('ZARAGALLO',26);
  
  
SELECT * FROM APELLIDOS_MOY;

SELECT * FROM APELLIDOS_MOY PARTITION (PRI);
SELECT * FROM APELLIDOS_MOY PARTITION (SEG);
SELECT * FROM APELLIDOS_MOY PARTITION (TER);
--SE METEN EN LA PARTICIÓN TERCERA LOS NOMBRES QUE NO SALEN EN LAS LISTAS. ESTO ES UTIL PARA EMPLEADOS...



-------EJERCICIO SIN LIST

DROP TABLE VENTAS_MOY PURGE;

CREATE TABLE VENTAS_MOY
(DNI NUMBER (9) CONSTRAINT PK_VENTAS_MOY_DNI PRIMARY KEY,
 NOM VARCHAR2 (20),
 FECHA_VENTA DATE
 )
 
 PARTITION BY RANGE (FECHA_VENTA)
 (PARTITION PRI_TRI VALUES LESS THAN (TO_DATE('01-04-2020','DD-MM-YYYY')),
  PARTITION SEG_TRI VALUES LESS THAN (TO_DATE('01-07-2020','DD-MM-YYYY')),
  PARTITION TER_TRI VALUES LESS THAN (TO_DATE('01-10-2020','DD-MM-YYYY')),
  PARTITION CUA_TRI VALUES LESS THAN (TO_DATE('01-01-2021','DD-MM-YYYY'))
  );
 
 INSERT INTO VENTAS_MOY VALUES (758475,'MOY','01-03-2020');
 INSERT INTO VENTAS_MOY VALUES (123654,'YOM','05-05-2020');
 INSERT INTO VENTAS_MOY VALUES (78548,'HUIJ','25-09-2020');
 INSERT INTO VENTAS_MOY VALUES (968574,'QWERTY','06-02-2020');
 INSERT INTO VENTAS_MOY VALUES (8574859,'QWERTY2','06-12-2020');

SELECT * FROM VENTAS_MOY;

SELECT * FROM VENTAS_MOY PARTITION (PRI_TRI);
SELECT * FROM VENTAS_MOY PARTITION (SEG_TRI);
SELECT * FROM VENTAS_MOY PARTITION (TER_TRI);
SELECT * FROM VENTAS_MOY PARTITION (CUA_TRI);

---------------------------------------RENOMBRAR PARTICOONES--------------------

ALTER TABLE VENTAS_MOY RENAME PARTITION CUA_TRI TO NUEVO_NOMBRE_PARTITION;

SELECT * FROM VENTAS_MOY PARTITION (NUEVO_NOMBRE_PARTITION);

ALTER TABLE VENTAS_MOY RENAME PARTITION NUEVO_NOMBRE_PARTITION TO CUA_TRI;

SELECT * FROM VENTAS_MOY PARTITION (CUA_TRI);


---------------------------------ELIMINAR UNA PARTICIÓN--------------------------

ALTER TABLE VENTAS_MOY DROP PARTITION (<NOMBRE_PARTICION>);

----------------------------------TRUNCAR PARTICIONES---------------------
--ME BORRA LOS DATOS PERO ME MANTIENE LA PARTICIÓN ***SI TRUNCAS TIENES QUE REPARAR EL INDICE, MIRAR MAS ABAJO***

ALTER TABLE VENTAS_MOY TRUNCATE PARTITION (<NOMBRE_PARTICION>);

--EJERCICIO

DROP TABLE VENTAS2_MOY PURGE;

CREATE TABLE VENTAS2_MOY
(DNI NUMBER PRIMARY KEY,
 NOM VARCHAR2(10)
)
PARTITION BY LIST(NOM)
 (PARTITION UNO VALUES ('PEPE', 'JOSE'),
  PARTITION DOS VALUES ('HOLA', 'ADIOS')
 );

INSERT INTO VENTAS2_MOY VALUES (1,'PEPE');
INSERT INTO VENTAS2_MOY VALUES (2,'ADIOS');

SELECT * FROM VENTAS2_MOY;

SELECT * FROM VENTAS2_MOY PARTITION (DOS);
SELECT * FROM VENTAS2_MOY PARTITION (UNO);


--PODEMOS ACTUALIZAR UNA TUPLA DE LA PARTICIÓN, SIEMPRE Y CUANDO LA PARTICIÓN O AFECTE A UNA PRIMARI KEY

--SI
UPDATE VENTAS2_MOY PARTITION (DOS)
 SET NOM = 'AIOS'
  WHERE DNI = 2;
  
--NO
UPDATE VENTAS2_MOY PARTITION (DOS)
 SET NOM = 'PEPE',
  WHERE DNI = 2;
  
--TRUNCAMOS LA PARTICIÓN

ALTER TABLE VENTAS2_MOY TRUNCATE PARTITION DOS;

INSERT INTO VENTAS2_MOY VALUES (3, 'PEPE'); --CASCA AHORA
INSERT INTO VENTAS2_MOY VALUES (4, 'HOLA'); --DA IGUAL LA PARTICIÓN, CASCA DESPUES DEL TRUNCATE

--HACEMOS UN STATUS PARA VER SU ESTADO
--DESPUES DE TRUNCATE LA TABLA CADA INUTILIZADA

SELECT STATUS FROM USER_INDEXES
 WHERE TABLE_NAME LIKE 'VENTAS2_MOY';
 
--COMPROVAMOS EL INDEX_NAME
SELECT USER_INDEXES.INDEX_NAME , STATUS FROM USER_INDEXES
 WHERE TABLE_NAME LIKE 'VENTAS2_MOY';

--TENEMOS QUE RECONSTRUIR EL INDICE CON:
ALTER INDEX SYS_C0011113 REBUILD;

--UNA VEZ REPARADO EL INDEX, YA PODEMOS VOLVER A INSERTAR TUPLAS
INSERT INTO VENTAS2_MOY VALUES (3, 'PEPE');
INSERT INTO VENTAS2_MOY VALUES (4, 'HOLA');

SELECT * FROM VENTAS2_MOY;

--PODEMOS GUARDAR EL REBUILD PARA QUE NO SE NOS OLVIDE DESPUES DE TRUNCAR CON <UPDATE GLOBAL INDEXES>

ALTER TABLE VENTAS2_MOY TRUNCATE PARTITION DOS UPDATE GLOBAL INDEXES;

--NO DA ERROR AHORA Y PODEMOS INSERTAR SIN PROBLEMAS.

INSERT INTO VENTAS2_MOY VALUES (3, 'PEPE');
INSERT INTO VENTAS2_MOY VALUES (4, 'HOLA');

SELECT * FROM VENTAS2_MOY;

--COMPROVAMOS EL INDEX Y COMPARAMOS
SELECT USER_INDEXES.INDEX_NAME , STATUS FROM USER_INDEXES
 WHERE TABLE_NAME IN ('CLIENTES','VENTAS2_MOY');
 


-------------------------------CORTAMOS Y PEGAMOS PARTICIONES----------------------------------
--CREAMOS UNA TABLA SIN PARTICIONAR, TAMBIEN PODRIA ESTAR PARTICIONADA, ESO DA IGUAL
DROP TABLE PARTEVENTAS_MOY PURGE;

CREATE TABLE PARTEVENTAS_MOY
(DNI NUMBER PRIMARY KEY,
 NOM VARCHAR2(10)
);
--COMPROVAMOS QUE VETNAS2_MOY TENGA TUPLAS EN LA PARTICIÓN
SELECT * FROM VENTAS2_MOY PARTITION (UNO);

--CORTAMOS LA PARTICIÓN DOS DE VENTAS2_MOY Y LA PEGAMOS EN LA TABLA PARTEVENTAS_MOY
ALTER TABLE VENTAS2_MOY EXCHANGE PARTITION UNO WITH TABLE PARTEVENTAS_MOY; --NO FUNCIONA UPDATE GLOBAL INDEXES;

--COMPROVAMOS QUE LOS DATOS EXISTEN, PERO NO SE PUEDEN MODIFICAR, ESTA UNUABLE
SELECT * FROM PARTEVENTAS_MOY;

--VEMOS CUAL ES EL ERROR DEL INDEX
SELECT USER_INDEXES.INDEX_NAME , STATUS FROM USER_INDEXES
 WHERE TABLE_NAME LIKE 'PARTEVENTAS_MOY';

--HACEMOS UN REUBILD DEL IDEX ERRONEO
ALTER INDEX SYS_C0011129 REBUILD;

--VOLVEMOS A COMPROBAR QUE YA NO ESTA UNUABLE, ESTA VALID

SELECT USER_INDEXES.INDEX_NAME , STATUS FROM USER_INDEXES
 WHERE TABLE_NAME LIKE 'PARTEVENTAS_MOY';
 
-----------------------------------------FUSIÓN DE PARTICIONES-----------------------------------------

ALTER TABLE VENTAS2_MOY MERGE PARTITIONS UNO, DOS INTO PARTITION UNO
      UPDATE GLOBAL INDEXES;

SELECT * FROM VENTAS2_MOY PARTITION (UNO);

SELECT * FROM VENTAS2_MOY PARTITION (DOS);--LA HEMOS BORRADO TOTALMENTE CON EL MERGE(FUSIÓN)

--ESTA EN INDEX VALID Y POR LO TANTO PODEMOS UTILIZAR SIN PROBLEMAS DML
SELECT USER_INDEXES.INDEX_NAME , STATUS FROM USER_INDEXES
 WHERE TABLE_NAME LIKE 'VENTAS2_MOY';
 

-------------------------------------------------OTROS SISTEMAS DE PARTICIONAMIENTO---------------------------------------
                         ---------------HASH------------------------
DROP TABLE VENTAS PURGE;

CREATE TABLE VENTAS
(DNI NUMBER PRIMARY KEY,
 NOM VARCHAR2 (30)
)
 PARTITION BY HASH (DNI) PARTITIONS 3;
 
 INSERT INTO VENTAS VALUES (1,'UNO');
 INSERT INTO VENTAS VALUES (3,'DOS');
 INSERT INTO VENTAS VALUES (3,'TRES');
 INSERT INTO VENTAS VALUES (4,'CUATRO');

--SACAMOS LOS NOMBRES DE LAS PARTITION
 SELECT * FROM USER_TAB_PARTITIONS
  WHERE TABLE_NAME LIKE 'VENTAS';

--COMPROBAMOS EN CUAL DE LAS PARTICIONES HA METIDO LAS TUPLAS. 
SELECT * FROM VENTAS PARTITION (SYS_P196);
SELECT * FROM VENTAS PARTITION (SYS_P197);
SELECT * FROM VENTAS PARTITION (SYS_P198); 

----------TAMBIEN PODEMOS ESPECIFICAR TABLESPACES

CREATE TABLE VENTAS
(DNI NUMBER PRIMARY KEY,
 NOM VARCHAR2 (30)
)
 PARTITION BY HASH (DNI)
 (PARTITION NOSE TABLESPACE USERS,
  PARTITION NOSE2 TABLESPACE USUDAW
  );
  


----------------------------------SUBPARTICIONAMIENTO CONPOSITE------------------------------
DROP TABLE ESTUDIANTES PURGE;

CREATE TABLE ESTUDIANTES
(CEDULA VARCHAR(19) NOT NULL,
 NOMBRES VARCHAR(40),
 APELLIDOS VARCHAR(40),
 SEXO CHAR(1),
 ID_ESCUELA INTEGER,
 CONSTRAINT PK_ESTUDIANTES PRIMARY KEY (CEDULA)
)
PARTITION BY RANGE (ID_ESCUELA)
 SUBPARTITION BY HASH (SEXO)
              SUBPARTITION TEMPLATE
              (SUBPARTITION MASCULINO,
               SUBPARTITION FEMENINO
              )
              (PARTITION DOS VALUES LESS THAN (2) TABLESPACE USERS,
               PARTITION TRES VALUES LESS THAN (3) TABLESPACE USERS,
               PARTITION CUATRO VALUES LESS THAN (4) TABLESPACE USERS,
               PARTITION CINCO VALUES LESS THAN (MAXVALUE) TABLESPACE USERS
              );
              
INSERT INTO ESTUDIANTES VALUES('22-A','PEPE','PEREZ','H',1);         
INSERT INTO ESTUDIANTES VALUES('23-A','ANA','GARCIA','M',2);  
INSERT INTO ESTUDIANTES VALUES('24-A','JUAN','GONZÁLEZ','H',2);  
INSERT INTO ESTUDIANTES VALUES('25-A','SANTIAGO','LIRÓN','H',3);  
INSERT INTO ESTUDIANTES VALUES('26-A','TAMARA','SANCHÉZ','M',4);  
INSERT INTO ESTUDIANTES VALUES('27-A','ALBERTO','BUENDÍA','H',2);  
INSERT INTO ESTUDIANTES VALUES('28-A','EVA','PEREZ','M',1);  
INSERT INTO ESTUDIANTES VALUES('29-A','ALICIA','RAMOS','M',4);  
INSERT INTO ESTUDIANTES VALUES('30-A','CRISTIANO','RONALDO','H',1); 
INSERT INTO ESTUDIANTES VALUES('31-A','Y ESTE','A VER','H',13);

--PARA VER LAS PARTCIONES
 SELECT * FROM USER_TAB_PARTITIONS
  WHERE TABLE_NAME LIKE 'ESTUDIANTES';
 
--PARA VER LAS SUBPARTICIONES
 SELECT * FROM USER_TAB_SUBPARTITIONS
  WHERE TABLE_NAME LIKE 'ESTUDIANTES';
  
SELECT * FROM ESTUDIANTES;

SELECT * FROM ESTUDIANTES PARTITION (DOS);
SELECT * FROM ESTUDIANTES SUBPARTITION (DOS_MASCULINO);

--RENOMBRAR UNA SUBPARTICIÓN
ALTER TABLE ESTUDIANTES RENAME PARTITION DOS TO DOSBIS;

--DEJA LAS SUBPARTICIONES SIN TOCARLAS, PERO PARA DEJARLO CONCLUENTE DEBERIAMOS DE TAMBIER RENOMBRAR LAS SUBPARTICIONES

ALTER TABLE ESTUDIANTES RENAME SUBPARTITION DOS_MASCULINO TO DOSBIS_MASCULINO;
ALTER TABLE ESTUDIANTES RENAME SUBPARTITION DOS_FEMENINO TO DOSBIS_FEMENINO;


SELECT * FROM ESTUDIANTES PARTITION (DOSBIS);
SELECT * FROM ESTUDIANTES SUBPARTITION (DOSBIS_MASCULINO);
SELECT * FROM ESTUDIANTES SUBPARTITION (DOSBIS_FEMENINO);

-----TRUNCATE CON SUBPARTICIONES

---FOR
ALTER TABLE ESTUDIANTES TRUNCATE SUBPARTITION DOSBIS_MASCULINO;

SELECT USER_INDEXES.INDEX_NAME , STATUS FROM USER_INDEXES
 WHERE TABLE_NAME LIKE 'ESTUDIANTES';
 
ALTER INDEX PK_ESTUDIANTES REBUILD;

ALTER TABLE ESTUDIANTES TRUNCATE SUBPARTITION DOSBIS_MASCULINO UPDATE GLOBAL INDEXES;



--------------------EJERCICIO PRACTICO----------
DROP TABLE ALUMNOS_MOY PURGE;
DROP TABLE ALUMNOS_MOY;

CREATE TABLE ALUMNOS_MOY
(DNI NUMBER (9) CONSTRAINT PK_ALUMNOS_MOY_DNI PRIMARY KEY,
 NOMBRE VARCHAR2(30),
 SEXO VARCHAR2(1),
 CURSO NUMBER(1)
 )
 
 PARTITION BY LIST (CURSO)
    SUBPARTITION BY LIST (SEXO)
       SUBPARTITION TEMPLATE
       (SUBPARTITION HOMBRES VALUES ('h', 'H'),
        SUBPARTITION MUJERES VALUES ('m', 'M')
        )
 (PARTITION PRIMERO VALUES (1),
  PARTITION SEGUNDO VALUES (2),
  PARTITION TERCERO VALUES (3)
  )
  PARALLEL 4;
  
  INSERT INTO ALUMNOS_MOY VALUES (123456789, 'FULANITO', 'H', 3 );
  INSERT INTO ALUMNOS_MOY VALUES (234567891, 'MENGANITO', 'H', 1 );
  INSERT INTO ALUMNOS_MOY VALUES (345678912, 'ZARAGALLO', 'M', 2 );
  INSERT INTO ALUMNOS_MOY VALUES (456789123, 'RASCAPERSIANAS', 'M', 3 );
  
  SELECT * FROM ALUMNOS_MOY;
  
  SELECT * FROM ALUMNOS_MOY PARTITION (TERCERO);
  SELECT * FROM ALUMNOS_MOY SUBPARTITION (PRIMERO_HOMBRES);
  SELECT * FROM ALUMNOS_MOY SUBPARTITION (SEGUNDO_HOMBRES);
  
  SELECT * FROM USER_TAB_SUBPARTITIONS
  WHERE TABLE_NAME LIKE 'ALUMNOS_MOY';
  
  ALTER TABLE ALUMNOS_MOY ADD PARTITION CUARTO VALUES (4);


-------------------------------------------------------------------------------
-------------------------PAPELERA-----------------------------------------------

SELECT * FROM USER_RECYCLEBIN;
SELECT * FROM RECYCLEBIN;
PURGE RECYCLEBIN;

----------------COMO RECUPERAR UNA TABLA BORRADA
DROP TABLE ALUMNOS_MOY PURGE;
DROP TABLE ALUMNOS_MOY;


FLASHBACK TABLE ALUMNOS_MOY TO BEFORE DROP;

FLASHBACK TABLE ALUMNOS_MOY TO BEFORE DROP RENAME TO NUEVA_ALUMNOS_MOY;

  SELECT * FROM NUEVA_ALUMNOS_MOY;

ALTER TABLE NUEVA_ALUMNOS_MOY RENAME TO ALUMNOS_MOY;

  SELECT * FROM ALUMNOS_MOY;




--------------------------------------------------------------------------------
---------------------------------INTERVALOS-------------------------------------
-------------------------------------------------------------------------------

--SELECT  NUMTOYMINTERVAL (<VALOR_NUMERICO>,<YEAR/MONTH>) FROM DUAL;

SELECT NUMTOYMINTERVAL (1, 'MONTH') FROM DUAL;
SELECT NUMTOYMINTERVAL (3, 'YEAR') FROM DUAL;

--SELECT NUMTODSINTERVAL (<VALOR_NUMERICO>,<DAY/HOURS/MINUTE/SECOND>) FROM DUAL;

SELECT NUMTODSINTERVAL (22, 'DAY') FROM DUAL; --EL INTERVALO VA HA SER DE 22 DIAS
SELECT NUMTODSINTERVAL (88, 'MINUTE') FROM DUAL; --EL INTERVALO VA HA SER DE 88 MINUTOS



